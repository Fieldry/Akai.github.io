<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Lab5-1课上实验</title>
    <link href="/2022/06/02/Lab5-1/"/>
    <url>/2022/06/02/Lab5-1/</url>
    
    <content type="html"><![CDATA[<h2 id="exam"><a href="#exam" class="headerlink" title="exam"></a>exam</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs.h</span><br><span class="hljs-comment">// 1st part</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">time_read</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 2nd part</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">raid0_write</span><span class="hljs-params">(u_int secno, <span class="hljs-type">void</span> *src, u_int nsecs)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">raid0_read</span><span class="hljs-params">(u_int secno, <span class="hljs-type">void</span> *dst, u_int nsecs)</span>;<br></code></pre></td></tr></table></figure><h3 id="第一部分-获取系统时间"><a href="#第一部分-获取系统时间" class="headerlink" title="第一部分 获取系统时间"></a>第一部分 获取系统时间</h3><p>这一部分较为简单，与<code>ide_read, ide_write</code>思路相同，都是调用<code>syscall_read_dev, syscall_write_dev</code>这两个函数，对设备的相关地址进行读写。</p><h3 id="第二部分-简易磁盘阵列"><a href="#第二部分-简易磁盘阵列" class="headerlink" title="第二部分 简易磁盘阵列"></a>第二部分 简易磁盘阵列</h3><p>这部分两个函数主要是对<code>ide_read, ide_write</code>两个函数的调用，这也是后面<code>Extra</code>题目的基础<code>level</code>。</p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>前面第二部分的进阶版，个人觉得主要难点在于校验码的读取，计算与比较。</p><p>先根据题目背景理清磁盘的结构：</p><ul><li><p>用$B_i$表示第$i$个数据块，其中$i\geq 0$</p></li><li><p>用$D_{j-k}$表示第$j$个磁盘的第$k$个扇区，其中$j&#x3D;1,2,3,4,5;k \geq 0$</p></li><li><p>磁盘由多个扇区构成(在题目图中扇区画成了圆柱体，也许有点容易误解)，每个磁盘中扇区的编号$k$与数据块编号$i$的关系为</p><p>$i&#x3D;floor(k&#x2F;2)$</p></li><li><p>前四个磁盘中，每两个扇区同属一块数据块，这样一共八个扇区构成了一个完整的数据块</p></li><li><p>第五个磁盘中，每个扇区存储的是校验码，由前四个磁盘中$k$值相同的扇区里的数据异或得到</p></li><li><p>通过计算我们可以得到，每一个扇区大小为512字节，即128个<code>int</code>型数据，这部分数据可以用<code>int data[8][128]</code>这样一个二维数组表示；而校验码则可以用<code>int check[2][128]</code>这样一个二维数组表示(这是我看了提供的Extra测试程序后才明白的，对于理清思路以及后面计算校验码还是挺有帮助的)</p></li><li><p>因此用<code>int **data</code>统一代指题目中的参数<code>src, dst</code>，那么对于$D_{j-k}, j \leq 4$</p><ul><li><p>若$k &amp; 1 &#x3D; 0$，则该扇区对应的内存首地址<code>int *entry = *(data + (j - 1) * 128)，</code>即<code>data[j - 1]</code></p><p>否则，其对应的内存首地址为<code>entry = data + (j - 1) * 128 + halfpg / 4</code>，</p><p>其中<code>halfpg = 0x800 = 128 * 4 * 4</code>，即<code>data[j - 1 + 4]</code>，</p><p>这里对应的内存地址也就是我们与磁盘交互时写入或者读出的内存虚地址</p></li><li><p>那么确定完首地址后，我们可以把其看成一个长度为128的<code>int</code>型一维数组，再去读取其中第$l$个整数时，</p><p>只需要用<code>*(entry + l)</code>，其中$0\leq l &lt; 128$</p></li></ul></li></ul><p>其余注意事项：</p><ul><li><p>由于<code>data</code>区域是一个页大小，实际上是没有内存空间给到第五个磁盘的，所以在读取和写入时，都是在函数内部开局部数组，这个在注意事项中也有提到</p></li><li><p>对于单个非校验码磁盘损坏恢复数据时，我的思路是先记下损坏磁盘的编号<code>invalid</code>，然后将五个磁盘读取的数据都异或一遍，其中有一块损坏了，那么并没有真正读取，在对应内存的数据是不确定的，不过不影响，再异或一遍损坏磁盘对应内存的数据。由于两个相同值异或结果为0，而所有数异或上0还是本身，这样就可以计算出正确值了</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七次作业第4题</title>
    <link href="/2022/06/01/%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%BD%9C%E4%B8%9A%E7%AC%AC4%E9%A2%98/"/>
    <url>/2022/06/01/%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%BD%9C%E4%B8%9A%E7%AC%AC4%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="21级数据结构第七次作业第4题-北京地铁乘坐线路查询（202205）"><a href="#21级数据结构第七次作业第4题-北京地铁乘坐线路查询（202205）" class="headerlink" title="21级数据结构第七次作业第4题 北京地铁乘坐线路查询（202205）"></a>21级数据结构第七次作业第4题 北京地铁乘坐线路查询（202205）</h1><h2 id="题目要点"><a href="#题目要点" class="headerlink" title="题目要点"></a>题目要点</h2><ul><li><strong>输入</strong>：起始站名和目的站名</li><li><strong>输出</strong>：从起始站到目的站的最短乘坐站换乘线路</li><li><strong>读入文件</strong>：文件宏观看由两部分构成：<ul><li>第一部分，即第一个数，说明文件中地铁线路总数</li><li>第二部分，对于每一条线路，说明其详细信息，其信息同样分为两个部分：<ul><li>第一小部分，就是每部分第一行两个数，分别是线路编号，和文件中列出的该条线路的地铁站数量（与该线路中实际地铁站数并不等价，下面会说到）</li><li>第二小部分，就是说明了每个地铁站的名字，和是否为换乘站</li></ul></li></ul></li><li><strong>输出信息</strong>：<ul><li>路径</li><li>地铁站名称</li><li>地铁线路号</li><li>乘坐站数</li></ul></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><ul><li>若某条地铁线为环线，则首站与末站信息相同（如北京地铁2号线，首站信息“西直门 1” ，末站信息为“西直门 1”）</li></ul></blockquote><p>​因此，对于2号线，实际只有18个地铁站，但是文件中列出了19个站，首尾是一样的，这点需要特殊判断</p><ul><li>对于有多条长度一样的线路，输出其中任意一条就好</li><li>注意输出格式，括号外为地铁线路，括号内为乘坐的站数</li></ul><h2 id="数据结构及算法"><a href="#数据结构及算法" class="headerlink" title="数据结构及算法"></a>数据结构及算法</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>题目要求使用<code>Dijkstra</code>算法</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>观察可得，地铁线路图是稀疏图，大部分都是度为2的点，因此考虑使用邻接表存储</li><li>邻接表的具体实现方式采用的是<strong>链式前向星</strong>（这个百度搜索可以找到很多教程，这里不再赘述）</li><li>每个结点，即每个地铁站，用结构体保存相应信息（也可以每条线路建立一个结构体，保存所有的地铁站，但是不建议，因为不方便存储换乘信息）</li><li>采用了堆优化（可选项，对于这个数据量优化意义不大）</li></ul><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><h3 id="读入文件"><a href="#读入文件" class="headerlink" title="读入文件"></a>读入文件</h3><ul><li>保存每个站的信息，如名称，是否可换乘</li><li>用邻接表保存地铁站之间的关系，即保存图的边</li><li>注意换乘信息如何保存以便于后续对图的遍历</li></ul><h3 id="寻找线路"><a href="#寻找线路" class="headerlink" title="寻找线路"></a>寻找线路</h3><p>这个应该难度不大，<code>Dijkstra</code>算法的简单应用</p><p>注意在过程中维护路径，用于后续输出答案</p><h3 id="输出答案"><a href="#输出答案" class="headerlink" title="输出答案"></a>输出答案</h3><ul><li>输出起始站，换乘站和终点站的名称，这个在读入时需要保存</li><li>输出乘坐的线路和站数<ul><li>站数不难计算，在回溯路径时计数就好</li><li>线路信息是可以保存在站结点的结构体中</li><li>稍微复杂的是如何判断在哪一站换乘，通过“两点确定一条直线(地铁线)”，分别判断当前站和下一站位于哪一条线路上，如果线路不一样，就是到了换乘站</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab04</title>
    <link href="/2022/06/01/Lab04/"/>
    <url>/2022/06/01/Lab04/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大作业常见问题</title>
    <link href="/2022/05/22/%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/05/22/%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="大作业常见问题"><a href="#大作业常见问题" class="headerlink" title="大作业常见问题"></a>大作业常见问题</h1><h2 id="基本注意事项"><a href="#基本注意事项" class="headerlink" title="基本注意事项"></a>基本注意事项</h2><blockquote><p>从命令行输入作为需要返回的检索结果数量NUM和作为检索的关键词串K1,K2,..,Km</p></blockquote><ul><li>注意是从命令行读入，而不是标准输入</li></ul><blockquote><p>若找到的网页文档数（即Sim值大于0的文档数，即包含所给关键词的文档数）少于NUM，则按实际数目输出（屏幕输出也如此）。</p></blockquote><ul><li>即只需要输出Sim值大于0的文档。</li></ul><blockquote><p>如果相关度Sim值相同，则按照网页序号由小到大的顺序输出！</p></blockquote><ul><li>即判断排序的逻辑时，不仅要考虑Sim值的大小，还要比较文章的序号。</li></ul><blockquote><p>若某个关键词未在文档集合中出现，则不用计算其IDFk，其对所有文档的相关度都为0。</p></blockquote><ul><li>若关键词的DNk为0，则跳过该关键词的相关度，否则计算时会有除0错误，或者计算出来的数为NaN。</li></ul><blockquote><p>网页文档间以换页符\f分隔。</p></blockquote><ul><li>换页符只出现在网页文档间，即最后一篇文档后是没有换页符的。</li></ul><blockquote><p>输入串K1 K2 .. Km中的停用词及非字典中单词将不进行相关度分析。</p></blockquote><ul><li><p>若关键词中有停用词或者非字典词，不应该带入计算，简而言之，有没有这个关键词对结果不影响</p></li><li><p>页数格式为’数字-数字’，可以用两个数字变量存储，或者直接按字符串读入</p></li></ul><h2 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h2><h3 id="读入"><a href="#读入" class="headerlink" title="读入"></a>读入</h3><ul><li>用<code>fgetc</code>读入字符时，一定要用<code>int</code>型的变量存储</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> c;<br><span class="hljs-keyword">while</span>(c = fgetc(in)) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>读入字典词或关键词时，注意最后一个词有没有读入</li><li>检查最后一篇文章有没有读入和处理，因为最后一篇文章后没有换页符</li><li>如果用<code>fgets</code>读标题行，一定要确定读的那一行是标题行，以下是错误示范</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\f&#x27;</span>) &#123;<br>fgetc(in);<span class="hljs-comment">// 读取换行符</span><br>fgets(...)<span class="hljs-comment">// 读取标题行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下仅供参考</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\f&#x27;</span>) &#123;<br>    <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c = fgetc(in)));<br>    ungetc(c, in);<br>    fgets(...);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用<code>fread</code>读入时要保存长度，并保证结束处有结束符，在处理时要保证不超过文章长度，以下仅供参考</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> leng;<br>FILE *art = fopen(<span class="hljs-string">&quot;article.txt&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>fseek(art, <span class="hljs-number">0L</span>, SEEK_END);<br>leng = ftell(art);<br>Art = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * (leng + <span class="hljs-number">1</span>));<br>fseek(art, <span class="hljs-number">0L</span>, SEEK_SET);<br>fread(Art, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), leng + <span class="hljs-number">1</span>, art);<br>Art[leng] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ul><li>数组的大小要仔细考量，或者开到一定大小保证不会越界，或者在访问数组前判断下标是否越界</li><li>注意数组存储下标的一致性，以下仅供参考</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>&#123;<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\f&#x27;</span>) &#123;<br>        <span class="hljs-comment">// do something</span><br>        cnt++;<br>    &#125;<br>&#125;<br>&#123;<br>    <span class="hljs-comment">// do something for the last article</span><br>&#125;<br>qsort(arr + <span class="hljs-number">1</span>, cnt, <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]), cmp);<br></code></pre></td></tr></table></figure><ul><li>注意浮点数的计算和比较，以下也仅供参考</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *v1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *v2)</span> &#123;<br>    Nodeptr n1 = (Nodeptr)v1, n2 = (Nodeptr)v2;<br>    <span class="hljs-keyword">if</span>(n1-&gt;sim - n2-&gt;sim &gt; eps) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n2-&gt;sim - n1-&gt;sim &gt; eps) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n1-&gt;id - n2-&gt;id;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab03</title>
    <link href="/2022/04/26/Lab03/"/>
    <url>/2022/04/26/Lab03/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="thinking-3-1"><a href="#thinking-3-1" class="headerlink" title="thinking 3.1"></a>thinking 3.1</h2><p>MOS中目前使用的<code>envid</code>是由三部分构成：</p><ul><li>第0-9位：当前进程在<code>envs</code>数组中偏移量，因为共有1024个<code>env</code>，故这部分占据10位</li><li>第10位：1</li><li>第11-16位：6位的<code>ASID</code></li></ul><p>低10位是不会出错的，这一步需要判断高7位是否符合<code>envid</code>的规则，以及<code>ASID</code>是否和低10位偏移量对应。</p><h2 id="thinking-3-2"><a href="#thinking-3-2" class="headerlink" title="thinking 3.2"></a>thinking 3.2</h2><ul><li><p>UTOP以下的区域是可读写区域，UTOP-ULIM间的区域是只读区域</p></li><li><p>自映射：</p><ul><li><code>UVPT</code>以上到<code>ULIM</code>之间，是一个4MB的空间，正好满足对整个4GB进程空间的自映射。</li><li>在根据页目录，以这4MB空间内的虚拟地址访问页表时，得到的<code>env_cr3</code>正是</li></ul></li><li><p>物理地址和虚拟地址：</p><ul><li>在MOS中，物理内存为64MB，这是所有进程共享的</li><li>对于<code>kuseg, kseg0</code>部分虚拟地址的访问，最终都是落到了访问对应的物理地址。物理地址是真正存储数据的地方</li><li>32位操作系统，虚拟内存共4GB，分为用户空间和内核空间。其中<code>kuseg</code>是用户空间，共2GB；<code>kseg0</code>是内核空间的一部分，也是内核空间中我们目前接触最多的部分，其大小为512MB</li><li>在<code>kuseg</code>空间中，通过二级页表机制将虚拟地址映射到不同的物理页；在<code>kseg0</code>空间中，通过将最高位抹去，直接映射到固定的物理页</li><li>所有进程共享内核所在的2GB空间</li></ul></li></ul><h2 id="thinking-3-3"><a href="#thinking-3-3" class="headerlink" title="thinking 3.3"></a>thinking 3.3</h2><p><code>user_data</code>为调用<code>load_icode</code>函数时传入的进程参数<code>e</code></p><h2 id="thinking-3-4"><a href="#thinking-3-4" class="headerlink" title="thinking 3.4"></a>thinking 3.4</h2><p>根据<code>va</code>和<code>va + bin_size</code>是否页对齐，可以分为四种情况：</p><ul><li><p><code>va</code>为页对齐，这种情况较为简单</p></li><li><p><code>va</code>不是页对齐，其中<code>offset = va - ROUNDDOWN(va, BY2PG)</code>，则从<code>va--ROUND(va, BY2PG)</code>这段区间需要单独加载，首先需要考虑<code>va</code>是否和物理页面有映射关系，如果有，则需要找到对应的物理页面；否则需要分配一个新的物理页</p><p><img src="/img/Lab03/4.1.jpg"></p></li><li><p><code>va + bin_size</code>为页对齐</p></li><li><p><code>va + bin_size</code>非页对齐，此时<code>offset = va + i - ROUNDDOWN(va + i, BY2PG)</code>，则从<code>ROUNDDOWN(va + i, BY2PG)--va + i</code>这段区间需要单独加载，即用offset代替BY2PG作为加载的size</p><p><img src="/img/Lab03/4.2.jpg"></p></li></ul><h2 id="thinking-3-5"><a href="#thinking-3-5" class="headerlink" title="thinking 3.5"></a>thinking 3.5</h2><ul><li><p>虚拟地址。</p></li><li><p>每个进程不一样。</p></li><li><blockquote><p><code>e_entry</code>：此字段指明程序入口的虚拟地址。即当文件被加载到进程空间里后，入口程序在进程地址空间里的地址。对于可执行程序文件来说，当 ELF 文件完成加载之 后，程序将从这里开始运行；而对于其它文件来说，这个值应该是 0。</p></blockquote></li></ul><h2 id="thinking-3-6"><a href="#thinking-3-6" class="headerlink" title="thinking 3.6"></a>thinking 3.6</h2><p><code>epc</code>是<code>CP0</code>寄存器组中记录异常发生地址的寄存器。在发生中断时，<code>CPU</code>会将发生中断的地址存入该寄存器。</p><p>在<code>env_pop_tf()</code>函数中，最后会跳转到进程的<code>pc</code>寄存器，但是在进程切换中，实际跳转的地方应该是<code>epc</code>寄存器，故要将<code>pc</code>寄存器中的值设置为<code>epc</code>。</p><h2 id="thinking-3-7"><a href="#thinking-3-7" class="headerlink" title="thinking 3.7"></a>thinking 3.7</h2><ul><li>在宏<code>SAVE_ALL</code>中，将当前进程的上下文存到<code>TIMESTACK</code></li><li>是内核区域中不同的栈区域，当出现时钟中断时，存储的区域为<code>TIMESTACK</code>，对于其它异常，存储区域为<code>KERNEL_SP</code></li></ul><h2 id="thinking-3-8"><a href="#thinking-3-8" class="headerlink" title="thinking 3.8"></a>thinking 3.8</h2><ul><li><code>handle_int: lib/genex.S</code></li><li><code>handle_mod, handle_tlb: lib/genex.S</code>，抽象成了函数<code>handle_\exception</code></li><li><code>handle_sys: lib/syscall.S</code></li></ul><h2 id="thinking-3-9"><a href="#thinking-3-9" class="headerlink" title="thinking 3.9"></a>thinking 3.9</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">.macro  setup_c0_status set clr<br>//定义了一个宏，将状态寄存器修改为设定值，若clr置1则清零<br>.set    push<br>    mfc0    t0, CP0_STATUS<br>    or      t0, \set|\clr<br>    xor     t0, \clr<br>    mtc0    t0, CP0_STATUS<br>    .set    pop<br>.endm<br><br>LEAF(set_timer)<br>        li t0, 0xc8//t0 &lt;- 200<br>        sb t0, 0xb5000100//将时钟中断设置为200次<br>        sw sp, KERNEL_SP//KERNEL_SP &lt;- sp, 将当前栈内容存入内核栈指针处<br>setup_c0_status STATUS_CU0|0x1001 0//CP0_STATUS &lt;- STATUS_CU0|0x1001=0x10001001<br>        jr ra//<br>        nop<br>END(set_timer)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">timer_irq:<br>sb zero, 0xb5000110//关闭时钟中断<br>1:  j       sched_yield//调用sched_yield函数<br>    nop<br>    /*li t1, 0xff<br>    lw    t0, delay<br>    addu  t0, 1<br>    sw      t0, delay<br>    beq     t0,t1,1f<br>    nop*/<br>    j       ret_from_exception//调用ret_from_exception函数<br>    nop<br></code></pre></td></tr></table></figure><h2 id="thinking-3-10"><a href="#thinking-3-10" class="headerlink" title="thinking 3.10"></a>thinking 3.10</h2><img src="/img/Lab03/异常处理.png" style="zoom:150%;" /><p>当发生时钟中断，先通过<code>except_vec3</code>异常分发进入对应处理异常函数，在本次实验中为中断处理函数<code>handle_int</code>。然后通过一些处理，比如保存现场等，之后通过判断中断码进入相应的中断服务函数，本次实验中为<code>timer_irq</code>。在该函数中主要工作为调用<code>sched_yield</code>函数调度进程，在该函数中会通过进程的优先级切换进程并运行，这便是根据时钟周期切换进程。</p><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><h2 id="进程创建流程及函数调用图"><a href="#进程创建流程及函数调用图" class="headerlink" title="进程创建流程及函数调用图"></a>进程创建流程及函数调用图</h2><p><img src="/img/Lab03/env_create.png"></p><h2 id="进程创建相关函数"><a href="#进程创建相关函数" class="headerlink" title="进程创建相关函数"></a>进程创建相关函数</h2><h3 id="env-create"><a href="#env-create" class="headerlink" title="env_create"></a><code>env_create</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：创建进程</p><h3 id="env-create-priority"><a href="#env-create-priority" class="headerlink" title="env_create_priority"></a><code>env_create_priority</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：创建进程</p><h3 id="env-alloc"><a href="#env-alloc" class="headerlink" title="env_alloc"></a><code>env_alloc</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：</p><ul><li>调用<code>env_setup_vm</code>函数，为进程分配页目录并完成部分映射</li><li>初始化对应PCB，主要包括<code>env_id, env_parent_id, env_status, env_runs, env_tf.cp0_status, env_tf.regs[29]</code></li><li>将进程从空闲链表中移出，加入调度队列(这和物理内存管理的页链表管理体系很类似)</li></ul><h3 id="env-setup-vm"><a href="#env-setup-vm" class="headerlink" title="env_setup_vm"></a><code>env_setup_vm</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：</p><ul><li><p>为进程的页目录分配物理页</p></li><li><p>以<code>UTOP</code>为界，将用户空间分别映射，映射的模板是之前虚拟内存初始化时得到的<code>boot_pgdir</code></p><ul><li><p><code>0--UTOP</code>间的用户空间是可读写的，且各个进程在这部分的内容是各不一样的，因此在该函数中我们将其全部清零</p></li><li><p><code>UTOP--UTPV</code>间的用户空间是存储<code>pages, envs</code>结构体数组的，这也是在之前虚拟内存初始化时完成映射的，这样在用户空间就可以访问到这两个数组。这部分对于所有进程都是相同的，因此我们以<code>boot_pgdir</code>为模板完成映射</p></li><li><p><code>UVPT--UTOP</code>间的用户空间是用来自映射的，这部分4MB空间正好可以映射整个4GB虚拟内存空间，我们用以下代码来初始化这块空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">e-&gt;env_pgdir = pgdir;<br>e-&gt;env_cr3 = PADDR(e-&gt;env_pgdir);<br>e-&gt;env_pgdir[PDX(UVPT)] = e-&gt;env_cr3 | PTE_V;<br></code></pre></td></tr></table></figure></li><li><p><code>UTOP</code>以上的空间不属于用户空间，也是用户态无法访问的内存空间</p></li></ul></li></ul><h2 id="进程加载相关函数"><a href="#进程加载相关函数" class="headerlink" title="进程加载相关函数"></a>进程加载相关函数</h2><h3 id="load-icode"><a href="#load-icode" class="headerlink" title="load_icode"></a><code>load_icode</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：</p><ul><li>分配物理页，并完成从用户栈空间到该物理页的映射</li><li>通过<code>load_elf</code>函数完成文件二进制数据到用户空间的映射</li><li>设置进程的入口，该入口地址通过上面的<code>load_elf</code>函数获得</li></ul><h3 id="load-elf"><a href="#load-elf" class="headerlink" title="load_elf"></a><code>load_elf</code></h3><p><strong>位置</strong>：<code>lib/kernel_elfloader.c</code></p><p><strong>说明</strong>：分段调用<code>load_icode_mapper</code>函数完成映射</p><h3 id="is-elf-format"><a href="#is-elf-format" class="headerlink" title="is_elf_format"></a><code>is_elf_format</code></h3><p><strong>位置</strong>：<code>lib/kernel_elfloader.c</code></p><p><strong>说明</strong>：判断文件是否符合<code>ELF</code>文件格式</p><h3 id="load-icode-mapper"><a href="#load-icode-mapper" class="headerlink" title="load_icode_mapper"></a><code>load_icode_mapper</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：将文件二进制数据映射到用户空间</p><h2 id="时钟中断处理图"><a href="#时钟中断处理图" class="headerlink" title="时钟中断处理图"></a>时钟中断处理图</h2><img src="/img/Lab03/异常处理.png" style="zoom:150%;" /><h2 id="异常处理相关函数"><a href="#异常处理相关函数" class="headerlink" title="异常处理相关函数"></a>异常处理相关函数</h2><h3 id="except-vec3"><a href="#except-vec3" class="headerlink" title="except_vec3"></a><code>except_vec3</code></h3><p><strong>位置</strong>：<code>boot/start.S</code></p><p><strong>说明</strong>：负责异常分发，根据状态寄存器的<code>ExCode</code>跳转到对应的异常处理函数</p><h3 id="handle-exception"><a href="#handle-exception" class="headerlink" title="handle_\exception"></a><code>handle_\exception</code></h3><p><strong>位置</strong>：<code>lib/genex.S</code></p><p><strong>说明</strong>：异常处理函数</p><h3 id="timer-irq"><a href="#timer-irq" class="headerlink" title="timer_irq"></a><code>timer_irq</code></h3><p><strong>位置</strong>：<code>lib/genex.S</code></p><p><strong>说明</strong>：时钟中断的处理函数</p><h3 id="sched-yield"><a href="#sched-yield" class="headerlink" title="sched_yield"></a><code>sched_yield</code></h3><p><strong>位置</strong>：<code>lib/sched.c</code></p><p><strong>说明</strong>：调度函数</p><h3 id="env-run"><a href="#env-run" class="headerlink" title="env_run"></a><code>env_run</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：运行进程</p><h3 id="ret-from-exception"><a href="#ret-from-exception" class="headerlink" title="ret_from_exception"></a><code>ret_from_exception</code></h3><p><strong>位置</strong>：<code>lib/genex.S</code></p><p><strong>说明</strong>：恢复现场</p><h2 id="异常处理相关宏定义"><a href="#异常处理相关宏定义" class="headerlink" title="异常处理相关宏定义"></a>异常处理相关宏定义</h2><h3 id="SAVE-ALL"><a href="#SAVE-ALL" class="headerlink" title="SAVE_ALL"></a><code>SAVE_ALL</code></h3><p><strong>位置</strong>：<code>include/stackframe.h</code></p><p><strong>位置</strong>：<code>boot/start.S</code></p><p><strong>说明</strong>：保存现场</p><h3 id="RESTORE-SOME-ALL"><a href="#RESTORE-SOME-ALL" class="headerlink" title="RESTORE_SOME/ALL"></a><code>RESTORE_SOME/ALL</code></h3><p><strong>位置</strong>：<code>include/stackframe.h</code></p><p><strong>说明</strong>：恢复现场</p><h3 id="get-sp"><a href="#get-sp" class="headerlink" title="get_sp"></a><code>get_sp</code></h3><p><strong>位置</strong>：<code>include/stackframe.h</code></p><p><strong>说明</strong>：获取保存现场的栈指针</p><h3 id="STI"><a href="#STI" class="headerlink" title="STI"></a><code>STI</code></h3><p><strong>位置</strong>：<code>include/stackframe.h</code></p><p><strong>说明</strong>：开启全局中断使能</p><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a><code>CLI</code></h3><p><strong>位置</strong>：<code>include/stackframe.h</code></p><p><strong>说明</strong>：禁用全局中断</p><h1 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h1><p>本次实验重点就是进程的创建和调度，以及简单异常的处理。</p><p>相关函数相比之前增加了很多，导致理清函数的调用关系成为了一个重点和前提，否则难以理清逻辑，更别谈去完成所有的函数了。</p><p>因此在反复学习指导书和阅读代码之后，在自己理解的基础上画了两个思维导图，以理清逻辑关系。</p>]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab02</title>
    <link href="/2022/04/15/Lab02/"/>
    <url>/2022/04/15/Lab02/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="thinking-2-1"><a href="#thinking-2-1" class="headerlink" title="thinking 2.1"></a>thinking 2.1</h2><p>1.虚拟地址</p><p>2.虚拟地址</p><h2 id="thinking-2-2"><a href="#thinking-2-2" class="headerlink" title="thinking 2.2"></a>thinking 2.2</h2><p>1.使用宏实现链表，不仅可以实现空页的链表管理，也可以实现空进程的链表管理。使用同一套宏可以实现多个链表的管理，大大提高了可重用性。</p><p>2.性能：</p><ol><li>单向链表</li></ol><p>​插入操作相对较为简单，因为不需要维护<code>le_prev</code>指针，但是性能相差不大</p><p>​删除操作单向链表更复杂，时间复杂度为<code>O(n)</code>，双向链表复杂度为<code>O(1)</code></p><ol start="2"><li>循环链表</li></ol><p>​插入操作简单，可以在<code>O(1)</code>时间内插入链表尾部，双向链表插入尾部复杂度为<code>O(n)</code></p><p>​删除操作与单向链表相同，时间复杂度为<code>O(n)</code></p><h2 id="thinking-2-3"><a href="#thinking-2-3" class="headerlink" title="thinking 2.3"></a>thinking 2.3</h2><p>C：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">le_next</span>;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> **<span class="hljs-title">le_prev</span>;</span><br>        &#125; pp_link;<br>        u_short pp_ref;<br>    &#125;* lh_first;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thinking-2-4"><a href="#thinking-2-4" class="headerlink" title="thinking 2.4"></a>thinking 2.4</h2><p><code>boot_map_segment()</code>：</p><p><code>boot_map_segment(pgdir, PAGES, n, PADDR(pages), PTE_R);</code></p><p><code>boot_map_segment(pgdir, ENVS, n, PADDR(envs), PTE_R);</code></p><p>在<code>mips_vm_init()</code>中被调用了两次，分别将<code>pages</code>数组的物理地址映射到以虚拟地址<code>UPAGE</code>为起始地址的内核页表，以及将<code>envs</code>数组的物理地址映射到以虚拟地址<code>UENV</code>为起始地址的内核页表。</p><p><code>boot_pgdir_walk</code>：</p><p><code>pgtable_entry = boot_pgdir_walk(pgdir, va_temp, 1);</code></p><p>由<code>boot_map_segment</code>调用。</p><h2 id="thinking-2-5"><a href="#thinking-2-5" class="headerlink" title="thinking 2.5"></a>thinking 2.5</h2><p>1.ASID：</p><p>在不同的进程中，有一部分虚拟内存是所有进程共享的，因此相同的虚拟内存，在不同的进程中回映射到不同的物理地址。为了区分不同进程的虚拟地址，引入了不同进程互不相同的ASID，在查找TLB时，需要传入虚地址和对应的ASID，这样才能正确查找到对应的物理地址。因此ASID是不可缺少的。</p><p>2.在不刷新旧的ASID值情况下，由于EntryHi寄存器中ASID值共6位，因此最多可以容纳64个不同的地址空间。</p><h2 id="thinking-2-6"><a href="#thinking-2-6" class="headerlink" title="thinking 2.6"></a>thinking 2.6</h2><ol><li></li></ol><p><code>tlb_invalidate</code>调用<code>tlb_out</code></p><ol start="2"><li></li></ol><p>根据当前进程的状态，以虚拟地址和进程的<code>ASID</code>值为参数调用<code>tlb_out</code>完成对<code>TLB</code>对应内容的清除</p><ol start="3"><li></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">LEAF(tlb_out)<br>        mfc0    k1,CP0_ENTRYHI//$k1 = $EntryHi，暂时保存原EntryHi寄存器值<br>        mtc0    a0,CP0_ENTRYHI//$EntryHi = $a0, 此时a0为调用tlb_out时传入的参数<br>        nop//空操作<br>        tlbp//tlbp, 根据EntryHi寄存器中的值查找对应的表项，并存入Index寄存器<br>        nop<br>        nop<br>        nop<br>        nop//空操作, tlbp需要的时钟数<br>        mfc0    k0,CP0_INDEX//$k0 = $Index<br>        bltz    k0,NOFOUND//if $k0 &lt; 0, 即Index寄存器最高位为1，代表未找到相应页，则跳转到&#x27;NOFOUND&#x27;<br>        nop//空操作<br>        mtc0    zero,CP0_ENTRYHI//$EntryHi = 0<br>        mtc0    zero,CP0_ENTRYLO0//$EntryLo = 0<br>        nop//空操作<br>        tlbwi//tlbwi, 根据Index寄存器中的索引将对应的EntryHi和EntryLo清零<br>NOFOUND:<br>        mtc0    k1,CP0_ENTRYHI//$EntryHi = $k1，将原EntryHi寄存器值写回<br><br>        j       ra//结束函数，返回<br>        nop//空操作<br>END(tlb_out)<br></code></pre></td></tr></table></figure><h2 id="thinking-2-7"><a href="#thinking-2-7" class="headerlink" title="thinking 2.7"></a>thinking 2.7</h2><p><code>PTbase</code>对应第<code>PTbase&gt;&gt;12</code>个页表项，每个页表项大小为<code>8B</code>，则偏移地址为<code>(PTbase&gt;&gt;12)&lt;&lt;3</code>，</p><p>则二级页表基地址为<code>PTbase|(PTbase&gt;&gt;12)&lt;&lt;3</code>。</p><p>同理可得，页目录基地址为<code>PTbase|(PTbase&gt;&gt;12)&lt;&lt;3|(PTbase&gt;&gt;21)&lt;&lt;3</code>，</p><p>而映射到页目录自身的页目录项地址为<code>PTbase|(PTbase&gt;&gt;12)&lt;&lt;3|(PTbase&gt;&gt;21)&lt;&lt;3|(PTbase&gt;&gt;30)&lt;&lt;3</code>。</p><h2 id="thinking-2-8"><a href="#thinking-2-8" class="headerlink" title="thinking 2.8"></a>thinking 2.8</h2><p>x86架构的内存管理分为两个部分，分段和分页。</p><p>分段提供了一种隔离每个进程或者任务代码、数据和栈模块的机制，保证多个进程或者任务能够在同一个处理器上运行而不会互相干扰。</p><p>分页机制实现了传统请求调页的虚拟内存系统，在这种系统中，程序的执行环境块按需要被映射到物理内存中。分页机制同样可以用来隔离多个任务。</p><p>对分页和分段机制进行不同的配置，可以分别支持简单的单任务系统、多任务系统或者使用共享内存的多处理器系统。</p><p>x86用到三个地址空间的概念：物理地址、线性地址和逻辑地址。而MIPS只有物理地址和虚拟地址两个概念。</p><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><h3 id="页式内存管理"><a href="#页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理</h3><p>MOS结构中采取页式管理结构，将物理内存总64MB按4KB一页分成16K页。</p><p>在物理内存管理中，通过<code>pages</code>结构体数组对这16K页进行管理。</p><p><code>Page</code>结构体中并没有记录太多复杂的信息，其中<code>pp_ref</code>记录了该物理内被映射的次数，<code>pp_link</code>是为了后续采取链表结构管理空闲链表所定义。每个<code>Page</code>结构体对应的物理页并不需要记录，因为结构体与物理页一一对应，通过<code>(p - pages)&lt;&lt;12</code>即可计算得到。</p><h3 id="链表管理空闲内存"><a href="#链表管理空闲内存" class="headerlink" title="链表管理空闲内存"></a>链表管理空闲内存</h3><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>对于空闲链表，MOS采取链表结构管理，并定义了一系列的宏便于操作。</p><p>理解并应用链表宏是物理内存管理的难点，下面把一些常用或者较为重要宏里的参数用<code>Page</code>结构体对应的变量代换以便于理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">LIST_HEAD(Page_list, Page)<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">lh_first</span>;</span><br>&#125;<br><span class="hljs-comment">//定义了一个Page_list结构体类型</span><br>LIST_ENTRY(Page)<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">le_next</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> **<span class="hljs-title">le_prev</span>;</span><br>&#125;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">LIST_ENTRY</span><span class="hljs-params">(Page)</span> Page_LIST_entry_t;<br><span class="hljs-comment">//定义了用于链表管理的page_entry</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>    Page_LIST_entry_t pp_link;<br>    u_short pp_ref;<br>&#125;<br><span class="hljs-comment">//定义了Page结构体</span><br>LIST_NEXT((page), pp_link)<br>page-&gt;pp_link.le_next<br></code></pre></td></tr></table></figure><p>通过转换以后可以很容易得到用于管理空闲链表的结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">le_next</span>;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> **<span class="hljs-title">le_prev</span>;</span><br>        &#125; pp_link;<br>        u_short pp_ref;<br>    &#125;* lh_first;<br>&#125;<br><span class="hljs-type">static</span> Page_list free_page_list;<br></code></pre></td></tr></table></figure><h4 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h4><p>在了解了数据结构以后，便可以着手编写宏函数了。</p><h5 id="LIST-INSERT-AFTER"><a href="#LIST-INSERT-AFTER" class="headerlink" title="LIST_INSERT_AFTER"></a>LIST_INSERT_AFTER</h5><p>由于双向链表的结构，<code>LIST_INSERT_AFTER(listelm, elm, field)</code>的实现并不难，先了解三个参数对应的含义：</p><ul><li><code>listelm</code>为链表中的元素，即用于定位的元素，在此函数中，新的元素需要被插入到该元素之后</li><li><code>elm</code>即为新的需要被插入到链表中的元素</li><li><code>field</code>是定义的用于链表管理的<code>entry</code>，在链表管理中，即为<code>Page</code>结构体中的<code>pp_link</code></li></ul><p>同样为了便于理解，把宏里的参数用<code>Page</code>结构体对应的变量代换得到代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">LIST_INSERT_AFTER(listpage, page, pp_link) <span class="hljs-keyword">do</span> &#123;     \<br>    LIST_NEXT((page), pp_link) = LIST_NEXT((listpage), pp_link);\<br><span class="hljs-keyword">if</span>(LIST_NEXT((listpage), pp_link) != <span class="hljs-literal">NULL</span>) \<br>        LIST_NEXT((listpage), pp_link)-&gt;pp_link.le_prev = &amp;LIST_NEXT((page), pp_link);  \<br>    LIST_NEXT((listpage), pp_link) = (page); \<br>(page)-&gt;pp_link.le_prev = &amp;LIST_NEXT((listpage), pp_link);\<br>&#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)                                                       <br></code></pre></td></tr></table></figure><p>如图所示:</p><p><img src="/img/Lab02/InkedLIST_INSERT_AFTER_LI.jpg"></p><h5 id="LIST-INSERT-TAIL"><a href="#LIST-INSERT-TAIL" class="headerlink" title="LIST_INSERT_TAIL"></a>LIST_INSERT_TAIL</h5><p>这个相对于前一个函数复杂的地方在于，首先需要判断链表是否为空，若非空则需要从头指针遍历直到最后一个节点，然后再仿照前一个函数将新元素插入尾部元素之后。而遍历是需要循环变量的，在编写这个函数时以为不可以在宏里定义新的变量，因此用<code>LIST_NEXT((page), pp_link)</code>作为循环变量，代换后代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INSERT_TAIL(head, page, pp_link) do &#123;                                    \</span><br><span class="hljs-meta"><span class="hljs-keyword">if</span> ((LIST_FIRST((head)) == NULL)) LIST_INSERT_HEAD(head, page, pp_link);   \</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span> &#123;                                                                  \</span><br><span class="hljs-meta">LIST_NEXT((page), pp_link) = LIST_FIRST((head));                               \</span><br><span class="hljs-meta">while (LIST_NEXT((LIST_NEXT((page), pp_link)), pp_link) != NULL) &#123;               \</span><br><span class="hljs-meta">LIST_NEXT((page), pp_link) = LIST_NEXT((LIST_NEXT((page), pp_link)), pp_link);  \</span><br><span class="hljs-meta">&#125; \</span><br><span class="hljs-meta">LIST_NEXT(LIST_NEXT((page), pp_link), pp_link) = (page);                          \</span><br><span class="hljs-meta">(page)-&gt;pp_link.le_prev = &amp;LIST_NEXT(LIST_NEXT((page), pp_link), pp_link);      \</span><br><span class="hljs-meta">LIST_NEXT((page), pp_link) = NULL;                                         \</span><br><span class="hljs-meta">&#125;                       \</span><br><span class="hljs-meta">&#125; while (0)</span><br></code></pre></td></tr></table></figure><blockquote><p>在写这个函数的时候有一个小问题，在找到最后一个元素后调用<code>LIST_INSERT_AFTER</code>会出错，应该是尾部元素之后的空指针导致的，但是具体问题还是没有发现。</p></blockquote><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><p>主要是<code>page_init(), page_alloc(), page_free()</code>三个函数，在理解和编写完宏函数之后，以及指导书中给定框架的帮助下，这些函数并不难完成。</p><p><strong>需要注意的是</strong>，调用<code>page_alloc()</code>后，通常需要给新的<code>Page</code>的<code>pp_ref++</code>；而调用<code>page_free()</code>前，需要给该<code>Page</code>的<code>pp_ref--</code>。</p><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><blockquote><p>在 R3000 上，虚拟地址映射到物理地址，随后使用物理地址来访存。与我们实验相关的映射与寻址规则（内存布局）如下：</p><ul><li>若虚拟地址处于 0x80000000~0x9fffffff (kseg0)，则将虚拟地址的最高位置 0得到物理地址，通过 cache 访存。这一部分用于存放内核代码与数据结构。</li><li>若虚拟地址处于 0xa0000000~0xbfffffff (kseg1)，则将虚拟地址的最高 3 位置0 得到物理地址，不通过 cache 访存。这一部分用于映射外设。</li><li>若虚拟地址处于 0x00000000~0x7fffffff (kuseg)，则需要通过 TLB 来获取物理地址，通过 cache 访存。</li></ul></blockquote><h3 id="kseg0"><a href="#kseg0" class="headerlink" title="kseg0"></a>kseg0</h3><p>对于处于<code>kseg0</code>内的虚拟地址，我们可以直接用如下两个宏来访问对应物理地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PADDR(kva)                                                      \</span><br><span class="hljs-meta">    (&#123;                                                                  \</span><br><span class="hljs-meta">        u_long a = (u_long)(kva);                                       \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (a &lt; ULIM)                        \</span><br><span class="hljs-meta">            panic(<span class="hljs-string">&quot;PADDR called with invalid kva %08lx&quot;</span>, a);            \</span><br><span class="hljs-meta">        a - ULIM;                                                       \</span><br><span class="hljs-meta">    &#125;)</span><br><span class="hljs-comment">//ULIM = 0x80000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KADDR(pa)                                                       \</span><br><span class="hljs-meta">    (&#123;                                                                  \</span><br><span class="hljs-meta">        u_long ppn = PPN(pa);   \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (ppn &gt;= npage)                         \</span><br><span class="hljs-meta">            panic(<span class="hljs-string">&quot;KADDR called with invalid pa %08lx&quot;</span>, (u_long)(pa));  \</span><br><span class="hljs-meta">        (pa) + ULIM;                                                    \</span><br><span class="hljs-meta">    &#125;)</span><br></code></pre></td></tr></table></figure><p>可以看到，在该区间内的虚拟和物理地址映射较为简单，就是最高位置1置0的区别。在转换之前，是有判断机制的，即<code>kva</code>应当大于<code>0x80000000</code>，否则不能使用该宏转换；<code>pa</code>对应的物理页框不能大于<code>npage</code>，其本质也就是<code>pa</code>要小于最大物理内存<code>64MB</code>，否则这个物理地址也是不合法的。</p><p>而我们的实验重点在于<code>kuseg</code>段，需要填写二级页表，并通过<code>TLB</code>来访问物理地址。</p><h3 id="kuseg"><a href="#kuseg" class="headerlink" title="kuseg"></a>kuseg</h3><h4 id="二级页表的填写"><a href="#二级页表的填写" class="headerlink" title="二级页表的填写"></a>二级页表的填写</h4><p>这是虚拟内存管理的重点，也是个人认为整个lab2中<strong>最难</strong>的部分。涉及到二级页表的相关知识，以及虚拟地址和物理地址的区别和联系。</p><p>首先借助指导书中的图便于理解二级页表的结构：</p><p><img src="/img/Lab02/pgdir.jpg"></p><p>整个二级页表的填写分为两个部分，使用两套配对的函数，时间分界点在于<code>page_init()</code>，但是整体过程是类似的：</p><ul><li>有变量<code>va, pa, pgdir, pgdir_entry, pgtable, pgtable_entry</code>，对应关系如上图所示，这些变量都是指明对应的地址，并不是地址里存的实际值</li><li>整个填写二级页表的流程大体如下：<ul><li>计算一级页目录入口<code>pgdir_entry = pgdir + PDX(va)</code></li><li>由一级页目录入口获得二级页表基地址<code>pgtable = KADDR(PTE_ADDR(*pgdir))</code></li><li>计算二级页表入口<code>pgtable_entry = pgtable + PTX(va)</code></li><li>为二级页表入口设置对应的物理地址页号<code>*pgtable_entry = PPN(pa) or *pgtable_entry = PPN(page2pa(page))</code></li></ul></li><li>在<code>page_init()</code>函数之前，使用<code>boot_pgdir_walk()</code>和<code>boot_map_segment()</code>函数完成填写，在其之后则使用<code>pgdir_walk()</code>和<code>page_insert()</code>函数完成填写。其中都是由后者调用前者，前者完成图示中的前三步，由后者完成第四步。</li></ul><h4 id="TLB的填写"><a href="#TLB的填写" class="headerlink" title="TLB的填写"></a>TLB的填写</h4><blockquote><p><strong>所有的在低 2GB 空间的访存操作都需要经过 TLB</strong>。</p></blockquote><p>TLB的重填本身是比较复杂的，不过本实验中并没有要求这个内容，只是要求完成<code>tlb_out</code>函数，这在理解TLB重填的过程后并不难，这里就不再展开了。但是理解TLB重填的过程还是十分重要的，在后续的实验中还会多次涉及。</p><h1 id="实验心得与总结"><a href="#实验心得与总结" class="headerlink" title="实验心得与总结"></a>实验心得与总结</h1><p>只能说lab2的难度比lab1又高了一个台阶，开启了真正的地狱模式。</p><p>即使是在lab2课下拿到了满分之后，对于二级页表映射，虚拟地址和物理地址还是不能完全搞明白。</p><p>直到lab3做了一部分以后，可能和lab2对照着看，终于算是理清了头绪。</p>]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab01</title>
    <link href="/2022/04/05/Lab01/"/>
    <url>/2022/04/05/Lab01/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="thinking1-1"><a href="#thinking1-1" class="headerlink" title="thinking1.1"></a>thinking1.1</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>-D : Display assembler contents of all sections</code>，即反汇编所有节的内容</p><p><code>-S : Intermix source code with disassembly</code>，显示与反汇编结合的源代码</p><h3 id="编译与反汇编Ⅰ"><a href="#编译与反汇编Ⅰ" class="headerlink" title="编译与反汇编Ⅰ"></a>编译与反汇编Ⅰ</h3><h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> c = a + b;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="反汇编main-o-只截取main代码段"><a href="#反汇编main-o-只截取main代码段" class="headerlink" title="反汇编main.o(只截取main代码段)"></a>反汇编main.o(只截取main代码段)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">00000000 &lt;main&gt;:<br>    0:   27bdffe0    addiu   sp,sp,-32//8 bytes<br>    4:   afbe0018    sw  s8,24(sp)//store $s8 into stack<br>    8:   03a0f021    move    s8,sp//store $sp into s8<br>    c:   24020001    li  v0,1//$v0 = 1<br>    10:   afc20010    sw  v0,16(s8)//<br>    14:   24020002    li  v0,2<br>    18:   afc2000c    sw  v0,12(s8)<br>    1c:   8fc30010    lw  v1,16(s8)<br>    20:   8fc2000c    lw  v0,12(s8)<br>    24:   00621021    addu    v0,v1,v0<br>    28:   afc20008    sw  v0,8(s8)<br>    2c:   00001021    move    v0,zero<br>    30:   03c0e821    move    sp,s8<br>    34:   8fbe0018    lw  s8,24(sp)<br>    38:   27bd0020    addiu   sp,sp,32<br>    3c:   03e00008    jr  ra<br>    40:   00000000    nop<br></code></pre></td></tr></table></figure><h4 id="反汇编main-只截取main代码段"><a href="#反汇编main-只截取main代码段" class="headerlink" title="反汇编main(只截取main代码段)"></a>反汇编main(只截取main代码段)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">004000b0 &lt;main&gt;:<br>    4000b0:   27bdffe0    addiu   sp,sp,-32<br>    4000b4:   afbe0018    sw  s8,24(sp)<br>    4000b8:   03a0f021    move    s8,sp<br>    4000bc:   24020001    li  v0,1<br>    4000c0:   afc20010    sw  v0,16(s8)<br>    4000c4:   24020002    li  v0,2<br>    4000c8:   afc2000c    sw  v0,12(s8)<br>    4000cc:   8fc30010    lw  v1,16(s8)<br>    4000d0:   8fc2000c    lw  v0,12(s8)<br>    4000d4:   00621021    addu    v0,v1,v0<br>    4000d8:   afc20008    sw  v0,8(s8)<br>    4000dc:   00001021    move    v0,zero<br>    4000e0:   03c0e821    move    sp,s8<br>    4000e4:   8fbe0018    lw  s8,24(sp)<br>    4000e8:   27bd0020    addiu   sp,sp,32<br>    4000ec:   03e00008    jr  ra<br>    4000f0:   00000000    nop<br></code></pre></td></tr></table></figure><p>在链接时进行了重定位，<code>main</code>地址不再是0，而是0x4000b0。</p><h3 id="编译与反汇编Ⅱ——反汇编vmlinux"><a href="#编译与反汇编Ⅱ——反汇编vmlinux" class="headerlink" title="编译与反汇编Ⅱ——反汇编vmlinux"></a>编译与反汇编Ⅱ——反汇编vmlinux</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">80010040 &lt;main&gt;:<br>    80010040:   27bdffe8    addiu   sp,sp,-24<br>    80010044:   afbf0010    sw  ra,16(sp)<br>    80010048:   3c048001    lui a0,0x8001<br>    8001004c:   0c00428e    jal 80010a38 &lt;printf&gt;<br>    80010050:   24840af8    addiu   a0,a0,2808<br>    80010054:   3c048001    lui a0,0x8001<br>    80010058:   24840b14    addiu   a0,a0,2836<br>    8001005c:   2405000a    li  a1,10<br>    80010060:   3c068001    lui a2,0x8001<br>    80010064:   0c00428e    jal 80010a38 &lt;printf&gt;<br>    80010068:   24c60b1c    addiu   a2,a2,2844<br>    8001006c:   0c004024    jal 80010090 &lt;mips_init&gt;<br>    80010070:   00000000    nop   <br>    80010074:   3c048001    lui a0,0x8001<br>    80010078:   24840b24    addiu   a0,a0,2852<br>    8001007c:   24050014    li  a1,20<br>    80010080:   3c068001    lui a2,0x8001<br>    80010084:   0c00429e    jal 80010a78 &lt;_panic&gt;<br>    80010088:   24c60b2c    addiu   a2,a2,2860<br>    8001008c:   00000000    nop<br></code></pre></td></tr></table></figure><h2 id="thinking1-2"><a href="#thinking1-2" class="headerlink" title="thinking1.2"></a>thinking1.2</h2><p>之前的<code>testELF</code>文件是小端编码，而内核文件<code>vmlinux</code>是大端编码，在读取数据时会产生错误，最终导致读取地址越界，因此我们的<code>readELF</code>程序并不能解析。</p><h2 id="thinking1-3"><a href="#thinking1-3" class="headerlink" title="thinking1.3"></a>thinking1.3</h2><p>因为在<code>GXemul</code>仿真器的帮助下，我们已经有了完整的C环境，只需要将内核加载后跳转到内核函数入口就可以启动完毕。</p><p>在链接器中，我们指定了内核加载的地址，并通过<code>start</code>中的代码，初始化硬件设备，设置堆栈入口，然后跳转到了内核函数入口处。</p><h2 id="thinking1-4"><a href="#thinking1-4" class="headerlink" title="thinking1.4"></a>thinking1.4</h2><p>避免<strong>页面冲突</strong>现象，即两个程序所占空间不能重合；</p><p>避免<strong>页面共享</strong>现象，即两个程序占据了同一页的空间。</p><p>对于当前程序加载时，应当以前一程序的尾地址<strong>向后</strong>页对齐后的地址作为起始地址，即保证两个程序不会占据同一页的空间，避免了页面共享和页面冲突现象。</p><h2 id="thinking1-5"><a href="#thinking1-5" class="headerlink" title="thinking1.5"></a>thinking1.5</h2><p>内核入口在<code>0x80010000</code></p><p><code>main</code>函数在<code>0x80010040</code>，从对<code>vmlinux</code>的反汇编中可以看到</p><p>在<code>start.S</code>文件中设置堆栈入口后，通过调用<code>main</code>函数，即<code>MIPS</code>中的<code>jal</code>指令，进入<code>main</code>函数</p><p>通过链接和重定位后，每个函数有自己的地址，可以通过<code>jal</code>进行跨文件调用函数</p><h2 id="thinking1-6"><a href="#thinking1-6" class="headerlink" title="thinking1.6"></a>thinking1.6</h2><p>将<code>CP0</code>的状态寄存器<code>STATUS REGISTER</code>置0，则其中的全局中断使能位也为0，禁用全局中断。</p><p>将<code>CP0</code>的<code>CONFIG</code>寄存器中值取出，将低三位置0又将第2位置1，则低三位K0区值为2，这时意为决定kseg0区不用高速缓存。</p><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><h2 id="难点一-ELF文件的解析"><a href="#难点一-ELF文件的解析" class="headerlink" title="难点一 ELF文件的解析"></a>难点一 ELF文件的解析</h2><p><img src="/img/Lab01/lab1-elf.png" alt="image"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>   e_ident[EI_NIDENT];     <span class="hljs-comment">/* Magic number and other info */</span><br>    <span class="hljs-comment">// 存放魔数以及其他信息</span><br>    Elf32_Half      e_type;                 <span class="hljs-comment">/* Object file type */</span><br>    <span class="hljs-comment">// 文件类型 </span><br>    Elf32_Half      e_machine;              <span class="hljs-comment">/* Architecture */</span><br>    <span class="hljs-comment">// 机器架构</span><br>    Elf32_Word      e_version;              <span class="hljs-comment">/* Object file version */</span><br>    <span class="hljs-comment">// 文件版本</span><br>    Elf32_Addr      e_entry;                <span class="hljs-comment">/* Entry point virtual address */</span><br>    <span class="hljs-comment">// 入口点的虚拟地址</span><br>    Elf32_Off       e_phoff;                <span class="hljs-comment">/* Program header table file offset */</span><br>    <span class="hljs-comment">// 程序头表所在处与此文件头的偏移</span><br>    Elf32_Off       e_shoff;                <span class="hljs-comment">/* Section header table file offset */</span><br>    <span class="hljs-comment">// 节头表所在处与此文件头的偏移</span><br>    Elf32_Word      e_flags;                <span class="hljs-comment">/* Processor-specific flags */</span><br>    <span class="hljs-comment">// 针对处理器的标记</span><br>    Elf32_Half      e_ehsize;               <span class="hljs-comment">/* ELF header size in bytes */</span><br>    <span class="hljs-comment">// ELF文件头的大小（单位为字节）</span><br>    Elf32_Half      e_phentsize;            <span class="hljs-comment">/* Program header table entry size */</span><br>    <span class="hljs-comment">// 程序头表入口大小</span><br>    Elf32_Half      e_phnum;                <span class="hljs-comment">/* Program header table entry count */</span><br>    <span class="hljs-comment">// 程序头表入口数</span><br>    Elf32_Half      e_shentsize;            <span class="hljs-comment">/* Section header table entry size */</span><br>    <span class="hljs-comment">// 节头表入口大小</span><br>    Elf32_Half      e_shnum;                <span class="hljs-comment">/* Section header table entry count */</span><br>    <span class="hljs-comment">// 节头表入口数</span><br>    Elf32_Half      e_shstrndx;             <span class="hljs-comment">/* Section header string table index */</span><br>    <span class="hljs-comment">// 节头字符串编号</span><br>&#125; Elf32_Ehdr;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-comment">// section name</span><br>  Elf32_Word sh_name;<br>  <span class="hljs-comment">// section type</span><br>  Elf32_Word sh_type;<br>  <span class="hljs-comment">// section flags</span><br>  Elf32_Word sh_flags;<br>  <span class="hljs-comment">// section addr</span><br>  Elf32_Addr sh_addr;<br>  <span class="hljs-comment">// offset from elf head of this entry</span><br>  Elf32_Off sh_offset;<br>  <span class="hljs-comment">// byte size of this section</span><br>  Elf32_Word sh_size;<br>  <span class="hljs-comment">// link</span><br>  Elf32_Word sh_link;<br>  <span class="hljs-comment">// extra info</span><br>  Elf32_Word sh_info;<br>  <span class="hljs-comment">// alignment</span><br>  Elf32_Word sh_addralign;<br>  <span class="hljs-comment">// entry size</span><br>  Elf32_Word sh_entsize;<br> &#125;Elf32_Shdr;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-comment">// segment type</span><br>  Elf32_Word p_type;<br>  <span class="hljs-comment">// offset from elf file head of this entry</span><br>  Elf32_Off p_offset;<br>  <span class="hljs-comment">// virtual addr of this segment</span><br>  Elf32_Addr p_vaddr;<br>  <span class="hljs-comment">// physical addr, in linux, this value is meanless and has same value of p_vaddr</span><br>  Elf32_Addr p_paddr;<br>  <span class="hljs-comment">// file size of this segment</span><br>  Elf32_Word p_filesz;<br>  <span class="hljs-comment">// memory size of this segment</span><br>  Elf32_Word p_memsz;<br>  <span class="hljs-comment">// segment flag</span><br>  Elf32_Word p_flags;<br>  <span class="hljs-comment">// alignment</span><br>  Elf32_Word p_align;<br> &#125;Elf32_Phdr;<br><br></code></pre></td></tr></table></figure><p>这是<code>Lab1</code>的第一道难关，也是第一次上机的重要考点，在反复阅读代码以及ELF手册后，终于明白了ELF文件大概布局和格式。</p><h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p>每个ELF文件有且仅有一个ELF Header，也就是上述定义为<code>Elf32_Ehdr</code>的结构体，在这里记录了整个ELF文件的重要信息，其中最值得关注的，例如：</p><ul><li><code>e_ident</code>：是ELF文件的标识符，一共16个字节的内容，其中前4字节又被称为魔数，用于标识这是一个ELF文件；第6个字节是数据编码格式，用于判断是小端存储还是大端存储。</li><li><code>e_entry</code>：程序入口的虚拟地址。</li><li><code>e_ehsize</code>：ELF文件头的大小。</li><li><code>e_phoff/e_shoff</code>：程序(节)头表的偏移地址，都是相对于ELF文件起始地址的偏移量</li><li><code>e_phentsize/e_shentsize</code>：程序(节)头表中每一表项的大小。</li><li><code>e_phnum/e_shnum</code>：程序(节)头表中表项的数量。</li></ul><p>了解后三个变量的定义后，就基本可以做出<code>exercise1.2</code>了。</p><h3 id="段与节"><a href="#段与节" class="headerlink" title="段与节"></a>段与节</h3><p>这是ELF文件中间的部分，也是文件真正的内容所在。</p><p>ELF文件有三种格式：可重定位文件，共享目标文件和可执行文件。</p><p>当文件为可重定位文件时，我们将中间部分称为节，这时在文件末尾的节头表相对更重要，它记录了所有节的信息；</p><p>当文件为另外两种类型时，我们将中间部分称为段，这时在文件头部的程序头表更为重要，它记录了所有段的信息。</p><p>总而言之，节与段只是在不同文件中表现形式的区别，实际上是同一部分内容。一般来说，段的数量会少于节，因为一个段一般会包含多个节的内容。</p><h3 id="程序头表与节头表"><a href="#程序头表与节头表" class="headerlink" title="程序头表与节头表"></a>程序头表与节头表</h3><p>从ELF文件布局图中看，这两个表一个在文件开头，一个在文件结尾(实际布局可能有所差异)。</p><p>之前提到过ELF文件头对应于一个ELF文件，在文件中有且仅有一个。</p><p>但是对于<code>Elf32_Shdr, Elf32_Shdr</code>两个结构体，每一个结构体就是表中的一个表项，对应于实际ELF文件中的一个节或段，记录了对应节或段的重要信息，其数量往往对应于文件中节或段的数量。</p><p>访问这两个表就需要我们借助ELF文件头中的信息。</p><p>以<code>exercise1.2</code>中访问节头表为例，先用<code>e_shoff</code>加上文件的起始地址，访问节头表的基地址；然后以<code>e_shentsize</code>作偏移，依次访问每一个节头表项，而节头表项的数量从<code>e_shnum</code>即可得知。</p><h2 id="难点二-实战printf"><a href="#难点二-实战printf" class="headerlink" title="难点二 实战printf"></a>难点二 实战printf</h2><h3 id="处理长参数表"><a href="#处理长参数表" class="headerlink" title="处理长参数表"></a>处理长参数表</h3><p>这个其实并不难，按照指导书提供的参数表格式依次处理就好。</p><p>需要注意的是对于参数的初始化，如<code>width = prec = 0, padc = &#39; &#39;</code>等。</p><h3 id="补充打印整数部分"><a href="#补充打印整数部分" class="headerlink" title="补充打印整数部分"></a>补充打印整数部分</h3><p>这部分也不难，相对其他部分，引入了<code>negFlag</code>这一变量，只需先对打印的参数进行判断，若为负数则将其变为正数并置<code>negFlag</code>为1。</p><h3 id="阅读代码并分析函数功能"><a href="#阅读代码并分析函数功能" class="headerlink" title="阅读代码并分析函数功能"></a>阅读代码并分析函数功能</h3><p>这一部分应该是完成<code>exercise1.5</code>的前置功课，这才是最难的部分，真正实操的部分反而简单。</p><p>一些宏函数和变量类型：</p><ul><li><code>va_list</code></li><li><code>va_start</code></li><li><code>va_arg</code></li><li><code>va_end</code></li></ul><p>以及三个<code>local help functions</code></p><ul><li><code>PrintNum</code></li><li><code>PrintChar</code></li><li><code>PrintString</code></li></ul><h1 id="实验心得与总结"><a href="#实验心得与总结" class="headerlink" title="实验心得与总结"></a>实验心得与总结</h1><p>总的来说这一次实验总体难度水平中等偏难，相对于Lab0的入门实验，难度肯定是有了较大的提升。但是作为后续实验的基础来说，后续的实验只会更难。</p><p>在刚开始阅读指导书的时候，什么都不知道，一头雾水。能把每个分散的exercise做好，但是对整体的知识体系结构还是一无所知。</p><p>在完成printf实战之后再回头梳理整个脉络后，就会对Lab1的整体结构有个较为清楚的把握。</p><p>以总的<code>Makefile</code>为基础，可以将Lab1的几乎所有文件夹串联起来：</p><ul><li><p><code>boot</code>文件夹中的<code>start.S</code>主要与启动相关，负责初始化硬件，设置堆栈入口，以及跳转到<code>main</code>函数</p></li><li><p><code>drivers</code>文件夹主要与外部硬件设备相关，如实现输出字符的地址定义就在这里<code>console.c</code>文件中</p></li><li><p><code>include</code>文件夹主要包括了一些库函数，宏定义文件</p></li><li><p><code>lib</code>文件夹则是包含了实现<code>printf</code>的文件</p></li><li><p><code>tools</code>文件夹中是负责链接的文件，定义了内核入口地址</p></li><li><p><code>init</code>文件夹中则是初始化和<code>main</code>函数文件，在Lab1中体现不多，在Lab2则是重点</p></li><li><p><code>readelf</code>则是为了让我们手写函数去解析ELF文件</p></li><li><p><code>gxemul</code>中是仿真器的位置</p></li></ul><p>理解以后自然觉得不难，这样梳理以后就会对整体结构清晰很多。</p>]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab00</title>
    <link href="/2022/03/22/Lab00/"/>
    <url>/2022/03/22/Lab00/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="thinking-0-1"><a href="#thinking-0-1" class="headerlink" title="thinking 0.1"></a>thinking 0.1</h2><h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><p>1.状态不同：第一次<code>add</code>之前，文件状态为<code>Untracked</code>，当<code>add</code>之后再次修改文件后，文件状态变为<code>Modified</code></p><p>2.操作不同：对于<code>Modified</code>状态下的文件，可以通过<code>git checkout -- &lt;file&gt;</code>将该文件变回修改前的状态</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>对于已经<code>git add</code>的文件，文件已经进入暂存区，这时在工作区再次修改时，和<code>add</code>前的状态是不同的；且可以通过暂存区的文件对工作区进行恢复。</p><h2 id="thinking-0-2"><a href="#thinking-0-2" class="headerlink" title="thinking 0.2"></a>thinking 0.2</h2><p><code>add the file: git add; git commit</code></p><p><code>stage the file: git add</code></p><p><code>commit: git commit</code></p><h2 id="thinking-0-3"><a href="#thinking-0-3" class="headerlink" title="thinking 0.3"></a>thinking 0.3</h2><p><code>git checkout -- printf.c</code></p><p><code>git reset HEAD printf.c</code></p><p><code>git rm --cached Tucao.txt</code></p><h2 id="thinking-0-4"><a href="#thinking-0-4" class="headerlink" title="thinking 0.4"></a>thinking 0.4</h2><p>对于每一次<code>git commit</code>操作，文件都会在版本库中被记录下来。</p><p>通过<code>git reset --hard &lt;Hash-code&gt;</code>操作，可以回溯到任意一个曾经<code>commit</code>的版本。</p><h2 id="thinking-0-5"><a href="#thinking-0-5" class="headerlink" title="thinking 0.5"></a>thinking 0.5</h2><p>1.正确。</p><p>通过本地测试，在本地克隆远程仓库后，只会在本地检出<code>HEAD</code>指向的分支，一般为<code>main/master</code>分支。</p><p>2.正确。</p><p>这四条指令都是本地的状态和提交记录，与远程仓库无关。</p><p>3.错误。</p><p>克隆时所有分支都被克隆，但只有<code>HEAD</code>指向的分支被检出，需要在本地创建其他分支与远程仓库建立联系。</p><p>4.正确。</p><p>通过本地实验后发现是正确的。</p><h2 id="thinking-0-6"><a href="#thinking-0-6" class="headerlink" title="thinking 0.6"></a>thinking 0.6</h2><p><img src="/img/Lab00/Lab00-6.png" alt="image-20220315150110794"></p><h2 id="thinking-0-7"><a href="#thinking-0-7" class="headerlink" title="thinking 0.7"></a>thinking 0.7</h2><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> Shell Start...&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo set a = 1&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> a=1 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo set b = 2&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> b=2 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo set c = a+b&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;c=$[$a+$b]&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo c = \$c&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save c to ./file1 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo $c&gt;file1&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save b to ./file2 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo $b&gt;file2&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save a to ./file3 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo $a&gt;file3&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file1 file2 file3 to file4 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;cat file1&gt;file4&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;cat file2&gt;&gt;file4&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;cat file3&gt;&gt;file4&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file4 to ./result &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;cat file4&gt;&gt;result&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="result"><a href="#result" class="headerlink" title="result"></a>result</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">Shell Start...<br>set a = 1<br>set b = 2<br>set c = a+b<br>c = 3<br>save c to ./file1<br>save b to ./file2<br>save a to ./file3<br>save file1 file2 file3 to file4<br>save file4 to ./result<br>3<br>2<br>1<br></code></pre></td></tr></table></figure><p><code>echo echo Shell Start</code>与<code>echo &#39;echo Shell Start&#39;</code>效果上没有区别；</p><p><code>echo echo \$c&gt;file1 </code>后，‘file1’中内容为<code>echo $c</code>;</p><p><code>echo &#39;echo \$c&gt;file1&#39;</code>后，标准输出为<code>echo \$c&gt;file1</code>。</p><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><p><code>git</code>文件状态和恢复操作一图。</p><p><img src="/img/Lab00/Lab00-1.png"></p><h1 id="总结感受"><a href="#总结感受" class="headerlink" title="总结感受"></a>总结感受</h1><p>在寒假预习了部分知识点的基础上，课下实验大约用4个小时左右的时间完成，总体来说Lab00课下实验难度不高。</p><p>Lab00主要在于对一些工具的了解和熟练掌握，在完成课下实验之后还需要不断学习巩固，为后面的学习做准备。</p><p>其中个人遇到的难点有：</p><p><code>git</code>操作较多，尤其是多种恢复操作，难以区分和记忆。</p><p><code>Linux</code>的<code>Shell</code>操作较多，熟练掌握需要一定的练习；<code>bash</code>批处理文件的编写也需要不断巩固，注意细节。</p>]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
