<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Symbol Table and Exception</title>
    <link href="/2022/09/24/Symbol%20Table%20and%20Exception/"/>
    <url>/2022/09/24/Symbol%20Table%20and%20Exception/</url>
    
    <content type="html"><![CDATA[<h1 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h1><h2 id="类的设计"><a class="markdownIt-Anchor" href="#类的设计"></a> 类的设计</h2><h3 id="sysytree"><a class="markdownIt-Anchor" href="#sysytree"></a> <code>SysYTree</code></h3><ul><li>主要作用：遍历抽象语法树，检查语义。</li><li>成员方法：<ul><li><code>SymbolTable check(SymbolTable table, boolean inLoop)</code>：在遍历过程中对所有语法结点检查语义。</li></ul></li></ul><p><img src="/img/Compiler/%E8%AF%AD%E6%B3%95%E6%A0%91.png" alt="" /></p><h3 id="sysyexception"><a class="markdownIt-Anchor" href="#sysyexception"></a> <code>SysYException</code></h3><ul><li>主要作用：错误类，继承自<code>Exception</code>。</li><li>成员属性：<ul><li><code>EKind kind</code>：错误种类。</li><li><code>int line</code>：错误所在行。</li></ul></li></ul><h3 id="symboltable"><a class="markdownIt-Anchor" href="#symboltable"></a> <code>SymbolTable</code></h3><ul><li>主要作用：建立符号表，用于错误处理。</li><li>成员属性：<ul><li><code>Map&lt;String, SysYSymbol&gt;</code>：根据符号名索引符号节点。</li><li><code>SymbolTable parent</code>：记录父符号表。</li></ul></li><li>成员方法：<ul><li><code>SysYSymbol findSymbol(String name)</code>：在当前符号表内查找符号。</li><li><code>SysYSymbol findSymbolInAll(String name)</code>：在当前符号表及所有父符号表中查找符号。</li><li><code>void addSymbol(SysYSymbol symbol)</code>：添加一个符号，若当前符号表中冲突则报错。</li></ul></li></ul><h3 id="writer"><a class="markdownIt-Anchor" href="#writer"></a> <code>Writer</code></h3><ul><li>主要作用：按格式输出错误行数及种类。</li><li>成员属性：<ul><li><code>List&lt;Token&gt; tokens</code>：记录该文件所有读入的<code>Token</code>。</li><li><code>String filename</code>：记录输出的文件名。</li><li><code>BufferedWriter bw</code>：用来输出文件内容。</li></ul></li><li>成员方法：<ul><li><code>void writeError(SysYException error)</code>：将错误按格式输出到对应文件中。</li></ul></li></ul><h3 id="compiler"><a class="markdownIt-Anchor" href="#compiler"></a> <code>Compiler</code></h3><ul><li>主要作用：主编译器，调用所有类和方法完成编译过程。</li></ul><h2 id="错误处理-2"><a class="markdownIt-Anchor" href="#错误处理-2"></a> 错误处理</h2><p>借鉴了<a href="https://github.com/Coekjan/MIPSysY-Compiler/">叶学长</a>的思路，将错误分为三类，分别在词法分析，语法分析和遍历语法树的过程中处理错误。</p><h3 id="词法分析过程"><a class="markdownIt-Anchor" href="#词法分析过程"></a> 词法分析过程</h3><p>a类错误比较简单，只需遍历一次字符串即可，且与其他错误关系不大，可以在词法分析中完成(当然，在后面完成也是可以的)。</p><h3 id="语法分析过程"><a class="markdownIt-Anchor" href="#语法分析过程"></a> 语法分析过程</h3><p>主要负责处理i，j，k类错误，这三个错误较为类似，与其他错误关系不大，且在生成抽象语法树时不会保存分隔符这些意义不大的信息，因此可以在语法分析过程中处理。</p><h3 id="遍历语法树过程"><a class="markdownIt-Anchor" href="#遍历语法树过程"></a> 遍历语法树过程</h3><p>剩下的复杂的错误都在这个过程中处理。</p><h2 id="基础设计"><a class="markdownIt-Anchor" href="#基础设计"></a> 基础设计</h2><h3 id="基类sysysymbol"><a class="markdownIt-Anchor" href="#基类sysysymbol"></a> 基类<code>SysYSymbol</code></h3><ul><li>需要加入到符号表中的类，包括<code>SysYDef, SysYFuncDef, SysYFuncParam, SysYMainFuncDef</code>。</li><li>定义了抽象方法<code>SymbolKind getKind()</code>，符号种类包括<code>CONST, VARIABLE, FUNCTION, PARAMETER, MAIN_FUNCTION</code>。</li></ul><h3 id="符号表类symboltable"><a class="markdownIt-Anchor" href="#符号表类symboltable"></a> 符号表类<code>SymbolTable</code></h3><ul><li>定义了成员属性<code>STkind kind</code>，符号表种类包括<code>INT_FUNCTION, VOID_FUNCTION, BLOCK</code>。</li><li>每次进入一个新的<code>block</code>时，需要新建一个符号表，根据是否为函数和函数返回类型赋予符号表种类，并与现符号表建立联系。</li></ul><h3 id="基类sysyexpression"><a class="markdownIt-Anchor" href="#基类sysyexpression"></a> 基类<code>SysYExpression</code></h3><ul><li>定义了抽象方法<code>ReturnKind getRetKind()</code>，返回值类型包括<code>VOID, INT, ONE_DIM, TWO_DIM</code>。</li></ul><h2 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现"></a> 具体实现</h2><p>主体函数为<code>SymbolTable check(SymbolTable table, boolean inLoop)</code>，对于每一个语法树结点，传入一个符号表，处理后返回一个符号表。</p><ul><li>b：在当前符号表内加入一个符号，若产生冲突则报错。</li><li>c：在当前符号表及其所有父符号表中查找该符号，若没有结果则报错。</li><li>d，e：<ul><li>遇到函数调用时，先搜索符号，若符号不存在或符号不是函数定义类，则报c类错误；</li><li>搜索到之后，判断形参个数与实参个数是否相同，不同则报d类错误；</li><li>再依次判断每个参数的类型是否符号，此处可以调用<code>getRetKind()</code>来判断。</li></ul></li><li>f，g：当进入一个<code>block</code>且该<code>block</code>对应的符号表为函数时，需要进行判断：<ul><li>若函数返回类型为<code>int</code>且函数体最后一句不为<code>return</code>，报g类错误；</li><li>若函数返回类型为<code>void</code>且函数体中出现某一句<code>return</code>后有返回值，报f类错误。</li></ul></li><li>h：在赋值语句检查时，若左值查找为常量则报错。</li><li>l：可以类比d类错误，不再赘述。</li><li>m：根据参数<code>inLoop</code>判断，记得在<code>while</code>结点检查时将<code>inLoop</code>设为<code>true</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Compiler</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Syntax Analysis</title>
    <link href="/2022/09/24/Syntax%20Analysis/"/>
    <url>/2022/09/24/Syntax%20Analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="语法分析"><a class="markdownIt-Anchor" href="#语法分析"></a> 语法分析</h1><h2 id="类的设计"><a class="markdownIt-Anchor" href="#类的设计"></a> 类的设计</h2><h3 id="sysytree"><a class="markdownIt-Anchor" href="#sysytree"></a> <code>SysYTree</code></h3><ul><li>主要作用：构建抽象语法树</li><li>内部类及关系如下图(强迫症为了布局看起来清楚已经花光了所有的精力，后面已经懒得写各个类的属性了)：</li></ul><p><img src="/img/Compiler/%E8%AF%AD%E6%B3%95%E6%A0%91.png" alt="" /></p><ul><li>这张图是最后完成了符号表构建和错误处理之后的终图，因此有些类是为了这两部分而设计。</li><li>每个结点包含必要的信息，举几个例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SysYDecl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SysYBlockItem</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> isConst;<br>    List&lt;SysYSymbol&gt; defs;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SysYDef</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SysYSymbol</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> isConst;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> dimensions;<br>    <span class="hljs-keyword">public</span> SysYExpression firstExp;<br>    <span class="hljs-keyword">public</span> SysYExpression secondExp;<br>    <span class="hljs-keyword">public</span> SysYExpression init;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SysYIf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SysYStatement</span> &#123;<br>    <span class="hljs-keyword">public</span> SysYExpression cond;<br>    <span class="hljs-keyword">public</span> SysYStatement thenStmt;<br>    <span class="hljs-keyword">public</span> SysYStatement elseStmt;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="scanner"><a class="markdownIt-Anchor" href="#scanner"></a> <code>Scanner</code></h3><ul><li>主要作用：在词法分析过程中保存<code>Token</code>，并在语法分析过程中提供<code>Token</code>。</li><li>成员属性：<ul><li><code>ArrayList&lt;Token&gt; tokens</code>：词法分析过程中所有读入的<code>Token</code>。</li><li><code>Token token</code>：当前<code>token</code>，通过<code>nextToken</code>设置。</li></ul></li><li>成员方法：<ul><li><code>void saveToken(Token token)</code>：保存一个<code>Token</code>。</li><li><code>void nextToken()</code>：读取下一个<code>Token</code>。</li><li><code>Token getToken()</code>：获得当前<code>Token</code>。</li><li><code>Token lookAhead(int pos)</code>：超前扫描<code>Token</code>。</li></ul></li></ul><h3 id="writer"><a class="markdownIt-Anchor" href="#writer"></a> <code>Writer</code></h3><ul><li>主要作用：按格式输出语法成分。</li><li>成员属性：<ul><li><code>List&lt;Token&gt; tokens</code>：记录该文件所有读入的<code>Token</code>。</li><li><code>String filename</code>：记录输出的文件名。</li><li><code>BufferedWriter bw</code>：用来输出文件内容。</li></ul></li><li>成员方法：<ul><li><code>void write(String out)</code>：将对应的语法成分输出到文件中。</li></ul></li></ul><h3 id="parser"><a class="markdownIt-Anchor" href="#parser"></a> <code>Parser</code></h3><ul><li>主要作用：语法分析器</li><li>成员方法：<ul><li><code>syntaxAnalyse</code>：进行语法分析，并返回顶端树节点<code>CompUnit</code>。</li><li>针对每一个非终结符，编写一个对应的<code>parse</code>方法，并返回树节点：<ul><li><code>public SysYCompUnit parseCompilationUnit();</code></li><li><code>public SysYStatement parseStatement();</code></li><li>…</li></ul></li></ul></li></ul><h3 id="compiler"><a class="markdownIt-Anchor" href="#compiler"></a> <code>Compiler</code></h3><ul><li>主要作用：主编译器，调用所有类和方法完成编译过程。</li></ul><h2 id="递归下降分析"><a class="markdownIt-Anchor" href="#递归下降分析"></a> 递归下降分析</h2><p>在<code>Parser</code>类中针对每个非终结符编写一个方法，用递归下降分析法，并在语法分析过程中构建抽象语法树。</p><p>个人设计过程中遇到的主要难点及注意事项：</p><ul><li><p>语法树的设计，类的继承和多态确实花了很多时间，在参考了<code>Javac</code>的设计和<a href="https://github.com/Coekjan/MIPSysY-Compiler/">叶学长</a>的设计后，最终确定了开篇所示的语法树结构。</p></li><li><p>对于变量初值<code>InitVal → Exp | '&#123;' [ InitVal &#123; ',' InitVal &#125; ] '&#125;'</code>：</p><ul><li>在读取到<code>'&#123;'</code>后可以判断下一个是不是<code>'&#125;'</code>来确定是否要递归读取<code>InitVal</code>；</li><li>对于重复出现的<code>InitVal</code>，可以用<code>','</code>作为循环判断的条件，对于类似的函数参数、变量定义也是一样，不建议使用<code>';'</code>作为分界符，因为错误处理时可能没有<code>';'</code>。</li></ul></li><li><p>区分函数定义和变量定义：</p><ul><li>读到<code>void</code>时，是函数定义；</li><li>读到<code>const</code>时，是常量定义；</li><li>读到<code>int</code>后，采用超前扫描判断标识符<code>ident</code>及其之后的符号：<ul><li>如果<code>ident</code>为<code>main</code>，是主函数定义；</li><li>如果是左小括号，是函数定义；</li><li>如果是赋值号，是变量定义。</li></ul></li></ul></li><li><p>区分<code>Stmt</code>语法成分的多种选择：</p><ul><li>读到左大括号，是<code>block</code>；</li><li>读到<code>if, while, break, continue, return, printf</code>，可以分别处理；</li><li>除此之外，有两种不同的方式区别赋值语句和单独的表达式：<ul><li>用<code>try...catch</code>先尝试按赋值语句读取：<ul><li>在读取<code>LVal</code>成分后读到了<code>'='</code>，则读取正确，之后读取<code>getint()</code>或<code>Exp</code>；</li><li>否则，读取<code>[Exp];</code>；</li><li>这种方式比较稳定，但是需要采取回溯的策略，具体如何回溯要根据自己读取<code>token</code>的方式；或者克隆一个<code>scanner</code>用来试错也是可行的。</li></ul></li><li>采用超前扫描，在记录读到下一个<code>';'</code>前是否读到过<code>'='</code>：<ul><li>若读到则为赋值语句，反之为表达式；</li><li>这种方式在错误处理时，如果该句结尾没有<code>';'</code>，可能会导致意想不到的结果；但是执行起来较为简单，超前扫描也不需要回溯。</li></ul></li></ul></li></ul></li><li><p>可以适当记录行号，之后错误处理会用到。</p></li><li><p>需要考虑好各个<code>parse</code>方法之间的关系，不要忘记在适当的时候读取下一个<code>token</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Compiler</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Token Analysis</title>
    <link href="/2022/09/12/Token%20Analysis/"/>
    <url>/2022/09/12/Token%20Analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析"></a> 词法分析</h1><h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>本人选的语言是<code>Java</code>，阅读和借鉴的源码是<code>Javac</code>的源码。选择<code>Java</code>的原因主要是22春的OOP课程用的比较多，比起<code>C++</code>来熟悉不少。最后选择<code>Javac</code>源码来阅读并借鉴主要原因有以下两点：</p><ul><li><code>Javac</code>源码自然是用<code>Java</code>语言书写的，那么在类的设计和使用等方面本身就有很多值得学习和借鉴的地方，之后在借鉴到的地方都会有所提及。</li><li><code>Java</code>语言的语法和<code>C</code>的语法有许多共通之处，比如变量类型需要申明，分支、循环语句的小括号和语句块的大括号，语句结尾需要分号等等。</li></ul><p>词法分析中我是按行读入的，可能比较少见，我把个人感觉到的按行读入的优缺点分析如下，仅供参考：</p><ul><li>优点：<ul><li>不需要处理换行符，也不需要考虑不同操作系统上换行符的变化带来的困扰，这也是我选择按行读入的主要原因。</li><li>对于单行注释符，读到以后可以直接读下一行，不需要持续读到换行符为止。</li><li>对于行数的记录一定不会出错。</li></ul></li><li>缺点：<ul><li>每一行都需要判断是否读完。</li><li>在多行注释状态下，既需要判断是否读到<code>*/</code>，还需要判断该行是否结束，较为繁琐。</li></ul></li></ul><p>不过缺点并不是致命的，都可以通过设计进行优化。</p><blockquote><p>其实就是当文档写的，希望之后重构得少一些。</p></blockquote><h2 id="类的设计"><a class="markdownIt-Anchor" href="#类的设计"></a> 类的设计</h2><h3 id="tokens"><a class="markdownIt-Anchor" href="#tokens"></a> <code>Tokens</code></h3><ul><li>主要作用：外部类，封装了关于<code>Token</code>的所有信息及方法。</li><li>静态成员属性：<ul><li><code>HashMap&lt;String, TokenKind&gt; keywords</code>：建立<code>Token</code>名字与<code>Tokenkind</code>之间的对应关系，主要便于之后查找一个<code>Token</code>是否为关键字。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (TokenKind t : TokenKind.values()) &#123;<br>    keywords.put(t.name, t);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>成员内部类：<ul><li><code>TokenKind</code></li><li><code>Token</code></li></ul></li><li>成员方法：<ul><li><code>TokenKind lookupKeywords(String name)</code>：根据<code>Token</code>名字返回其<code>TokenKind</code>，主要用于识别<code>Token</code>是否为关键字。</li></ul></li></ul><h3 id="tokenkind"><a class="markdownIt-Anchor" href="#tokenkind"></a> <code>TokenKind</code></h3><ul><li>主要作用：枚举类，记录所有种类的<code>Token</code>及其类别码。</li><li>成员属性：<ul><li><code>String name</code>：对于关键字和操作符，我赋值为对应的字符串；对于常数，标识符和格式字符串三类，这里的名字比较随意。其实这个属性也可以不需要，主要是为了建立<code>keywords</code>这个对应关系。</li><li><code>String code</code>：实验要求输出的类别码。</li></ul></li><li>举几个简单的例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">TokenKind</span> &#123;<br>    IDENT(<span class="hljs-string">&quot;identifier&quot;</span>, <span class="hljs-string">&quot;IDENFR&quot;</span>),<br>    INTC(<span class="hljs-string">&quot;int const&quot;</span>, <span class="hljs-string">&quot;INTCON&quot;</span>),<br>    FORMATS(<span class="hljs-string">&quot;format string&quot;</span>, <span class="hljs-string">&quot;STRCON&quot;</span>),<br>VOID(<span class="hljs-string">&quot;void&quot;</span>),<br>    GETINT(<span class="hljs-string">&quot;getint&quot;</span>),<br>    PLUS(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;PLUS&quot;</span>),<br>    GEQ(<span class="hljs-string">&quot;&gt;=&quot;</span>, <span class="hljs-string">&quot;GEQ&quot;</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String code;<br>    <br>    TokenKind(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.code = <span class="hljs-built_in">this</span>.name.toUpperCase() + <span class="hljs-string">&quot;TK&quot;</span>;<br>    &#125;<br><br>    TokenKind(String name, String code) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.code = code;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.code; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="token"><a class="markdownIt-Anchor" href="#token"></a> <code>Token</code></h3><ul><li>主要作用：记录<code>Token</code>的名字，种类，所在行数，值等信息。</li><li>成员属性：<ul><li><code>TokenKind tokenKind</code></li><li><code>int line</code>：记录所在行数。</li><li><code>String value</code>：记录常数，标识符和格式字符串的值(统一用<code>String</code>是偷懒了，对于常数可以在用的时候再转一下)。</li></ul></li></ul><blockquote><p>这里增加一个<code>value</code>是因为枚举类无法实例化对象，想在枚举类里枚举所有的常数，标识符和字符串显然不现实，所以在这里记录。</p></blockquote><h3 id="reader"><a class="markdownIt-Anchor" href="#reader"></a> <code>Reader</code></h3><ul><li>主要作用：阅读文章，记录当前字符和标识符内容。</li><li>成员属性：<ul><li><code>char ch</code>：当前字符。</li><li><code>char[] buf</code>：当前缓冲区。</li><li><code>int bp</code>：下一个需要读入的字符。</li><li><code>int len</code>：缓冲区长度。</li><li><code>char[] sbuf</code>：用来保存<code>Token</code>内容的字符数组。</li><li><code>int sp</code>：<code>sbuf</code>的下标。</li><li><code>String filename</code>：记录读入的文件名。</li><li><code>BufferedReader br</code>：用来读入文件内容。</li></ul></li><li>成员方法：<ul><li><code>boolean readNextLine()</code>：读入下一行文件内容。</li><li><code>boolean readChar()</code>：读入下一个字符。</li><li><code>void putChar()</code>：将当前字符保存进字符数组。</li><li><code>String savedToken()</code>：返回当前字符数组里保存的<code>Token</code>内容。</li><li><code>boolean is*()</code>：判断当前字符的种类，如<code>isPlus(), isStar()</code>等。</li></ul></li></ul><h3 id="writer"><a class="markdownIt-Anchor" href="#writer"></a> <code>Writer</code></h3><ul><li>主要作用：保存并按格式输出<code>Token</code>。</li><li>成员属性：<ul><li><code>List&lt;Token&gt; tokens</code>：记录该文件所有读入的<code>Token</code>。</li><li><code>String filename</code>：记录输出的文件名。</li><li><code>BufferedWriter bw</code>：用来输出文件内容。</li></ul></li><li>成员方法：<ul><li><code>void saveToken(Token token)</code>：保存一个<code>Token</code>。</li><li><code>void writeToken()</code>：按格式输出所有的<code>Token</code>。</li></ul></li></ul><h3 id="tokenizer"><a class="markdownIt-Anchor" href="#tokenizer"></a> <code>Tokenizer</code></h3><ul><li>主要作用：每次读入一个<code>Token</code>并返回。</li><li>成员方法：<ul><li><code>Token readToken()</code>：每次读入一个<code>Token</code>并返回。</li></ul></li></ul><h3 id="compiler"><a class="markdownIt-Anchor" href="#compiler"></a> <code>Compiler</code></h3><ul><li>主要作用：主编译器，调用所有类和方法完成编译过程。</li></ul><h2 id="状态图"><a class="markdownIt-Anchor" href="#状态图"></a> 状态图</h2><p><img src="/img/Compiler/%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="" /></p><p><img src="/img/Compiler/%E8%AF%8D%E6%B3%95%E5%9B%BE.png" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>Compiler</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab5-1课上实验</title>
    <link href="/2022/06/02/Lab5-1/"/>
    <url>/2022/06/02/Lab5-1/</url>
    
    <content type="html"><![CDATA[<h2 id="exam"><a class="markdownIt-Anchor" href="#exam"></a> exam</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs.h</span><br><span class="hljs-comment">// 1st part</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">time_read</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 2nd part</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">raid0_write</span><span class="hljs-params">(u_int secno, <span class="hljs-type">void</span> *src, u_int nsecs)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">raid0_read</span><span class="hljs-params">(u_int secno, <span class="hljs-type">void</span> *dst, u_int nsecs)</span>;<br></code></pre></td></tr></table></figure><h3 id="第一部分-获取系统时间"><a class="markdownIt-Anchor" href="#第一部分-获取系统时间"></a> 第一部分 获取系统时间</h3><p>这一部分较为简单，与<code>ide_read, ide_write</code>思路相同，都是调用<code>syscall_read_dev, syscall_write_dev</code>这两个函数，对设备的相关地址进行读写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">time_read</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> ret, update = <span class="hljs-number">0</span>, time;<br><br>ret = syscall_read_dev(&amp;time, <span class="hljs-number">0x15000010</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-comment">// 这里用了循环是因为题目中说到获取的时间可能“始终”为0</span><br>    <span class="hljs-comment">// 也许一次更新就行了，上机时没试过</span><br><span class="hljs-keyword">while</span>(ret == <span class="hljs-number">0</span> &amp;&amp; time == <span class="hljs-number">0</span>) &#123;<br>ret = syscall_write_dev(&amp;update, <span class="hljs-number">0x15000000</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)<br>user_panic(<span class="hljs-string">&quot;time_read error!&quot;</span>);<br>ret = syscall_read_dev(&amp;time, <span class="hljs-number">0x15000010</span>, <span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) user_panic(<span class="hljs-string">&quot;time_read error!&quot;</span>);<br><span class="hljs-keyword">if</span>(time) <span class="hljs-keyword">return</span> time;<br><span class="hljs-keyword">else</span> user_panic(<span class="hljs-string">&quot;time_read error!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二部分-简易磁盘阵列"><a class="markdownIt-Anchor" href="#第二部分-简易磁盘阵列"></a> 第二部分 简易磁盘阵列</h3><p>这部分两个函数主要是对<code>ide_read, ide_write</code>两个函数的调用，这也是后面<code>Extra</code>题目的基础<code>level</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">raid0_write</span><span class="hljs-params">(u_int secno, <span class="hljs-type">void</span> *src, u_int nsecs)</span> &#123;<br><span class="hljs-type">int</span> curno = secno, endno = secno + nsecs, diskno;<br><span class="hljs-type">int</span> offset = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(curno &lt; endno) &#123;<br><span class="hljs-keyword">if</span>(curno &amp; <span class="hljs-number">1</span>) diskno = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span> diskno = <span class="hljs-number">1</span>;<br>ide_write(diskno, curno / <span class="hljs-number">2</span>, src + offset, <span class="hljs-number">1</span>);<br>curno++;<br>offset += <span class="hljs-number">0x200</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">raid0_read</span><span class="hljs-params">(u_int secno, <span class="hljs-type">void</span> *dst, u_int nsecs)</span> &#123;<br><span class="hljs-type">int</span> curno = secno, endno = secno + nsecs, diskno;<br><span class="hljs-type">int</span> offset = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(curno &lt; endno) &#123;<br><span class="hljs-keyword">if</span>(curno &amp; <span class="hljs-number">1</span>) diskno = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span> diskno = <span class="hljs-number">1</span>;<br>ide_read(diskno, curno / <span class="hljs-number">2</span>, dst + offset, <span class="hljs-number">1</span>);<br>curno++;<br>offset += <span class="hljs-number">0x200</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="extra"><a class="markdownIt-Anchor" href="#extra"></a> Extra</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs.h</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">raid4_valid</span><span class="hljs-params">(u_int diskno)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">raid4_write</span><span class="hljs-params">(u_int blockno, <span class="hljs-type">void</span> *src)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">raid4_read</span><span class="hljs-params">(u_int blockno, <span class="hljs-type">void</span> *dst)</span>;<br></code></pre></td></tr></table></figure><p>前面第二部分的进阶版，个人觉得主要难点在于校验码的读取，计算与比较。</p><h3 id="大致思路"><a class="markdownIt-Anchor" href="#大致思路"></a> 大致思路</h3><p>先根据题目背景理清磁盘的结构：</p><ul><li><p>用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">B_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数据块，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i\geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p></li><li><p>用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">D_{j-k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个磁盘的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个扇区，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">;</mo><mi>k</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j=1,2,3,4,5;k \geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p></li><li><p>磁盘由多个扇区构成(在题目图中扇区画成了圆柱体，也许有点容易误解)，每个磁盘中扇区的编号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>与数据块编号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的关系为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i=floor(k/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></p></li><li><p>前四个磁盘中，每两个扇区同属一块数据块，这样一共八个扇区构成了一个完整的数据块</p></li><li><p>第五个磁盘中，每个扇区存储的是校验码，由前四个磁盘中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>值相同的扇区里的数据异或得到</p></li><li><p>通过计算我们可以得到，每一个扇区大小为512字节，即128个<code>int</code>型数据，这部分数据可以用<code>int data[8][128]</code>这样一个二维数组表示；而校验码则可以用<code>int check[2][128]</code>这样一个二维数组表示(这是我看了提供的Extra测试程序后才明白的，对于理清思路以及后面计算校验码还是挺有帮助的)</p></li><li><p>因此用<code>int **data</code>统一代指题目中的参数<code>src, dst</code>，那么对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi></mrow></msub><mo separator="true">,</mo><mi>j</mi><mo>≤</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">D_{j-k}, j \leq 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span></p><ul><li><p>若<code>k&amp;1=0</code>，则该扇区对应的内存首地址<code>int *entry = *(data + (j - 1) * 128)</code>，即<code>data[j-1]</code>；</p><p>否则，其对应的内存首地址为<code>entry = *(data + (j - 1) * 128 + halfpg / 4)</code>，即<code>data[j-1+4]</code>，</p><p>其中<code>halfpg = 0x800 = 128 * 4 * 4</code>，这里对应的内存地址也就是我们与磁盘交互时写入或者读出的内存虚地址</p></li><li><p>那么确定完首地址后，我们可以把其看成一个长度为128的<code>int</code>型一维数组，再去读取其中第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个整数时，只需要用<code>*(entry + n)</code>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>&lt;</mo><mn>128</mn></mrow><annotation encoding="application/x-tex">0\leq n &lt; 128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span></p></li></ul></li></ul><p>其余注意事项：</p><ul><li><p>由于<code>data</code>区域是一个页大小，实际上是没有内存空间给到第五个磁盘的，所以在读取和写入时，都是在函数内部开局部数组，这个在注意事项中也有提到</p></li><li><p>对于单个非校验码磁盘损坏恢复数据时，我的思路是先记下损坏磁盘的编号<code>invalid</code>，然后将五个磁盘读取的数据都异或一遍，其中有一块损坏了，那么并没有真正读取其内部的数据，在对应内存的数据是不确定的，不过不影响，再异或一遍损坏磁盘对应内存的数据。由于两个相同值异或结果为0，而所有数异或上0还是本身，这样就可以计算出正确值了</p></li></ul><h3 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h3><p>与上述思路有所出入，在读取单个整数时可以优化如思路所说，但是考试时来不及了…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">raid4_valid</span><span class="hljs-params">(u_int diskno)</span> &#123;<br><span class="hljs-type">int</span> ret;<br><span class="hljs-type">int</span> offset = <span class="hljs-number">0</span>, read = <span class="hljs-number">0</span>;<br>ret = syscall_write_dev(&amp;diskno, <span class="hljs-number">0x13000010</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) user_panic(<span class="hljs-string">&quot;raid4_valid error!&quot;</span>);<br><br>ret = syscall_write_dev(&amp;offset, <span class="hljs-number">0x13000000</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) user_panic(<span class="hljs-string">&quot;raid4_valid error!&quot;</span>);<br><br>ret = syscall_write_dev(&amp;read, <span class="hljs-number">0x13000020</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) user_panic(<span class="hljs-string">&quot;raid4_valid error!&quot;</span>);<br><br><span class="hljs-keyword">if</span>(syscall_read_dev(&amp;ret, <span class="hljs-number">0x13000030</span>, <span class="hljs-number">4</span>) &lt; <span class="hljs-number">0</span>)<br>user_panic(<span class="hljs-string">&quot;raid4_valid error!&quot;</span>);<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">raid4_write</span><span class="hljs-params">(u_int blockno, <span class="hljs-type">void</span> *src)</span> &#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">// invalid num</span><br><span class="hljs-type">int</span> offset = <span class="hljs-number">0</span>, diskno = <span class="hljs-number">1</span>, halfpg = <span class="hljs-number">0x800</span>; <br><span class="hljs-type">int</span> check[<span class="hljs-number">2</span>][<span class="hljs-number">128</span>], i;<br><span class="hljs-keyword">while</span> (diskno &lt;= <span class="hljs-number">4</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(raid4_valid(diskno)) &#123;<br>ide_write(diskno, <span class="hljs-number">2</span> * blockno, src + offset, <span class="hljs-number">1</span>);<br>ide_write(diskno, <span class="hljs-number">2</span> * blockno + <span class="hljs-number">1</span>, src + offset + halfpg, <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> res++;<br>diskno++;<br>offset += <span class="hljs-number">0x200</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(raid4_valid(diskno)) &#123;<br>user_bzero(check, <span class="hljs-number">1024</span>);<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++) &#123;<br>check[<span class="hljs-number">0</span>][i] = *(<span class="hljs-type">int</span> *)(src + <span class="hljs-number">4</span> * i);<br>check[<span class="hljs-number">1</span>][i] = *(<span class="hljs-type">int</span> *)(src + halfpg + <span class="hljs-number">4</span> * i);<br><span class="hljs-keyword">for</span>(offset = <span class="hljs-number">0x200</span>; offset &lt; <span class="hljs-number">0x800</span>; offset += <span class="hljs-number">0x200</span>) &#123;<br>check[<span class="hljs-number">0</span>][i] ^= *(<span class="hljs-type">int</span> *)(src + offset + <span class="hljs-number">4</span> * i);<br>check[<span class="hljs-number">1</span>][i] ^= *(<span class="hljs-type">int</span> *)(src + offset + halfpg + <span class="hljs-number">4</span> * i);<br>&#125;<br>&#125;<br>ide_write(diskno, <span class="hljs-number">2</span> * blockno, (<span class="hljs-type">void</span> *)check[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);<br>ide_write(diskno, <span class="hljs-number">2</span> * blockno + <span class="hljs-number">1</span>, (<span class="hljs-type">void</span> *)check[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> res++;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">raid4_read</span><span class="hljs-params">(u_int blockno, <span class="hljs-type">void</span> *dst)</span> &#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">// invalid num</span><br><span class="hljs-type">int</span> invalid = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> offset = <span class="hljs-number">0</span>, diskno = <span class="hljs-number">1</span>, halfpg = <span class="hljs-number">0x800</span>; <br><span class="hljs-type">int</span> check[<span class="hljs-number">2</span>][<span class="hljs-number">128</span>], i;<br><span class="hljs-type">int</span> check0, check1;<br><span class="hljs-keyword">while</span> (diskno &lt;= <span class="hljs-number">5</span>) &#123;<br><span class="hljs-keyword">if</span>(!raid4_valid(diskno)) res++;<br>diskno++;<br>&#125;<br><span class="hljs-keyword">if</span>(res &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res;<br><span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 读取前四块磁盘数据</span><br>        diskno = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (diskno &lt;= <span class="hljs-number">4</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(raid4_valid(diskno)) &#123;<br>ide_read(diskno, <span class="hljs-number">2</span> * blockno, dst + offset, <span class="hljs-number">1</span>);<br>ide_read(diskno, <span class="hljs-number">2</span> * blockno + <span class="hljs-number">1</span>, dst + offset + halfpg, <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> invalid = diskno;<br>diskno++;<br>offset += <span class="hljs-number">0x200</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(res == <span class="hljs-number">1</span> &amp;&amp; invalid == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// invalid为0说明是5号磁盘损坏，可以直接返回1</span><br><span class="hljs-keyword">else</span> &#123;<br>user_bzero(check, <span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">// 读取第五块磁盘数据到局部数组</span><br>ide_read(diskno, <span class="hljs-number">2</span> * blockno, (<span class="hljs-type">void</span> *)check[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);<br>ide_read(diskno, <span class="hljs-number">2</span> * blockno + <span class="hljs-number">1</span>, (<span class="hljs-type">void</span> *)check[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(res == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++) &#123;<br>check0 = *(<span class="hljs-type">int</span> *)(dst + <span class="hljs-number">4</span> * i);<br>check1 = *(<span class="hljs-type">int</span> *)(dst + halfpg + <span class="hljs-number">4</span> * i);<br><span class="hljs-keyword">for</span>(offset = <span class="hljs-number">0x200</span>; offset &lt; <span class="hljs-number">0x800</span>; offset += <span class="hljs-number">0x200</span>) &#123;<br>check0 ^= *(<span class="hljs-type">int</span> *)(dst + offset + <span class="hljs-number">4</span> * i);<br>check1 ^= *(<span class="hljs-type">int</span> *)(dst + offset + halfpg + <span class="hljs-number">4</span> * i);<br>&#125;<br><span class="hljs-keyword">if</span>(check0 != check[<span class="hljs-number">0</span>][i] || check1 != check[<span class="hljs-number">1</span>][i]) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++) &#123;<br>check0 = check[<span class="hljs-number">0</span>][i];<br>check1 = check[<span class="hljs-number">1</span>][i];<br><span class="hljs-keyword">for</span>(offset = <span class="hljs-number">0</span>; offset &lt; <span class="hljs-number">0x800</span>; offset += <span class="hljs-number">0x200</span>) &#123;<br>check0 ^= *(<span class="hljs-type">int</span> *)(dst + offset + <span class="hljs-number">4</span> * i);<br>check1 ^= *(<span class="hljs-type">int</span> *)(dst + offset + halfpg + <span class="hljs-number">4</span> * i);<br>&#125;<br>check0 ^= *(<span class="hljs-type">int</span> *)(dst + (invalid - <span class="hljs-number">1</span>) * <span class="hljs-number">0x200</span> + <span class="hljs-number">4</span> * i);<br>check1 ^= *(<span class="hljs-type">int</span> *)(dst + (invalid - <span class="hljs-number">1</span>) * <span class="hljs-number">0x200</span> + halfpg + <span class="hljs-number">4</span> * i);<br>*(<span class="hljs-type">int</span> *)(dst + (invalid - <span class="hljs-number">1</span>) * <span class="hljs-number">0x200</span> + <span class="hljs-number">4</span> * i) = check0;<br>*(<span class="hljs-type">int</span> *)(dst + (invalid - <span class="hljs-number">1</span>) * <span class="hljs-number">0x200</span> + halfpg + <span class="hljs-number">4</span> * i) = check1;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h3><p>如果按照思路所写，那么也许可以优化成以下这样(没提交过，咱也不确定)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 以raid4_write为例</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">raid4_write</span><span class="hljs-params">(u_int blockno, <span class="hljs-type">void</span> *src)</span> &#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">// invalid num</span><br><span class="hljs-type">int</span> offset = <span class="hljs-number">0</span>, diskno = <span class="hljs-number">1</span>, halfpg = <span class="hljs-number">0x800</span>; <br><span class="hljs-type">int</span> check[<span class="hljs-number">2</span>][<span class="hljs-number">128</span>], i, j;<br>    <span class="hljs-type">int</span> (*data)[][<span class="hljs-number">128</span>] = src;<br><span class="hljs-keyword">while</span> (diskno &lt;= <span class="hljs-number">4</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(raid4_valid(diskno)) &#123;<br>ide_write(diskno, <span class="hljs-number">2</span> * blockno, src + offset, <span class="hljs-number">1</span>);<br>ide_write(diskno, <span class="hljs-number">2</span> * blockno + <span class="hljs-number">1</span>, src + offset + halfpg, <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> res++;<br>diskno++;<br>offset += <span class="hljs-number">0x200</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(raid4_valid(diskno)) &#123;<br>user_bzero(check, <span class="hljs-number">1024</span>);<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++) &#123;<br>check[<span class="hljs-number">0</span>][i] = (*data)[<span class="hljs-number">0</span>][i];<br>check[<span class="hljs-number">1</span>][i] = (*data)[<span class="hljs-number">4</span>][i];<br><span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">3</span>; j++) &#123;<br>check[<span class="hljs-number">0</span>][i] ^= (*data)[j][i];<br>check[<span class="hljs-number">1</span>][i] ^= (*data)[<span class="hljs-number">4</span> + j][i];<br>&#125;<br>&#125;<br>ide_write(diskno, <span class="hljs-number">2</span> * blockno, (<span class="hljs-type">void</span> *)check[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);<br>ide_write(diskno, <span class="hljs-number">2</span> * blockno + <span class="hljs-number">1</span>, (<span class="hljs-type">void</span> *)check[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> res++;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七次作业第4题</title>
    <link href="/2022/06/01/%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%BD%9C%E4%B8%9A%E7%AC%AC4%E9%A2%98/"/>
    <url>/2022/06/01/%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%BD%9C%E4%B8%9A%E7%AC%AC4%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="21级数据结构第七次作业第4题-北京地铁乘坐线路查询202205"><a class="markdownIt-Anchor" href="#21级数据结构第七次作业第4题-北京地铁乘坐线路查询202205"></a> 21级数据结构第七次作业第4题 北京地铁乘坐线路查询（202205）</h1><h2 id="题目要点"><a class="markdownIt-Anchor" href="#题目要点"></a> 题目要点</h2><ul><li><strong>输入</strong>：起始站名和目的站名</li><li><strong>输出</strong>：从起始站到目的站的最短乘坐站换乘线路</li><li><strong>读入文件</strong>：文件宏观看由两部分构成：<ul><li>第一部分，即第一个数，说明文件中地铁线路总数</li><li>第二部分，对于每一条线路，说明其详细信息，其信息同样分为两个部分：<ul><li>第一小部分，就是每部分第一行两个数，分别是线路编号，和文件中列出的该条线路的地铁站数量（与该线路中实际地铁站数并不等价，下面会说到）</li><li>第二小部分，就是说明了每个地铁站的名字，和是否为换乘站</li></ul></li></ul></li><li><strong>输出信息</strong>：<ul><li>路径</li><li>地铁站名称</li><li>地铁线路号</li><li>乘坐站数</li></ul></li></ul><h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2><blockquote><ul><li>若某条地铁线为环线，则首站与末站信息相同（如北京地铁2号线，首站信息“西直门 1” ，末站信息为“西直门 1”）</li></ul></blockquote><p>​因此，对于2号线，实际只有18个地铁站，但是文件中列出了19个站，首尾是一样的，这点需要特殊判断</p><ul><li>对于有多条长度一样的线路，输出其中任意一条就好</li><li>注意输出格式，括号外为地铁线路，括号内为乘坐的站数</li></ul><h2 id="数据结构及算法"><a class="markdownIt-Anchor" href="#数据结构及算法"></a> 数据结构及算法</h2><h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3><p>题目要求使用<code>Dijkstra</code>算法</p><h3 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h3><ul><li>观察可得，地铁线路图是稀疏图，大部分都是度为2的点，因此考虑使用邻接表存储</li><li>邻接表的具体实现方式采用的是<strong>链式前向星</strong>（这个百度搜索可以找到很多教程，这里不再赘述）</li><li>每个结点，即每个地铁站，用结构体保存相应信息（也可以每条线路建立一个结构体，保存所有的地铁站，但是不建议，因为不方便存储换乘信息）</li><li>采用了堆优化（可选项，对于这个数据量优化意义不大）</li></ul><h2 id="整体思路"><a class="markdownIt-Anchor" href="#整体思路"></a> 整体思路</h2><h3 id="读入文件"><a class="markdownIt-Anchor" href="#读入文件"></a> 读入文件</h3><ul><li>保存每个站的信息，如名称，是否可换乘</li><li>用邻接表保存地铁站之间的关系，即保存图的边</li><li>注意换乘信息如何保存以便于后续对图的遍历</li></ul><h3 id="寻找线路"><a class="markdownIt-Anchor" href="#寻找线路"></a> 寻找线路</h3><p>这个应该难度不大，<code>Dijkstra</code>算法的简单应用</p><p>注意在过程中维护路径，用于后续输出答案</p><h3 id="输出答案"><a class="markdownIt-Anchor" href="#输出答案"></a> 输出答案</h3><ul><li>输出起始站，换乘站和终点站的名称，这个在读入时需要保存</li><li>输出乘坐的线路和站数<ul><li>站数不难计算，在回溯路径时计数就好</li><li>线路信息是可以保存在站结点的结构体中</li><li>稍微复杂的是如何判断在哪一站换乘，通过“两点确定一条直线(地铁线)”，分别判断当前站和下一站位于哪一条线路上，如果线路不一样，就是到了换乘站</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab04</title>
    <link href="/2022/06/01/Lab04/"/>
    <url>/2022/06/01/Lab04/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大作业常见问题</title>
    <link href="/2022/05/22/%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/05/22/%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="大作业常见问题"><a class="markdownIt-Anchor" href="#大作业常见问题"></a> 大作业常见问题</h1><h2 id="基本注意事项"><a class="markdownIt-Anchor" href="#基本注意事项"></a> 基本注意事项</h2><blockquote><p>从命令行输入作为需要返回的检索结果数量NUM和作为检索的关键词串K1,K2,…,Km</p></blockquote><ul><li>注意是从命令行读入，而不是标准输入</li><li>命令行输入时，<code>argv[0]</code>是当前程序的路径，在本题中不需要考虑；<code>argv[1]</code>是<code>num</code>，从<code>argc[2]</code>到<code>argv[argc-1]</code>为关键词。</li></ul><blockquote><p>若找到的网页文档数（即Sim值大于0的文档数，即包含所给关键词的文档数）少于NUM，则按实际数目输出（屏幕输出也如此）。</p></blockquote><ul><li>即只需要输出Sim值大于0的文档。</li></ul><blockquote><p>如果相关度Sim值相同，则按照网页序号由小到大的顺序输出！</p></blockquote><ul><li>即判断排序的逻辑时，不仅要考虑Sim值的大小，还要比较文章的序号。</li></ul><blockquote><p>若某个关键词未在文档集合中出现，则不用计算其IDFk，其对所有文档的相关度都为0。</p></blockquote><ul><li>若关键词的DNk为0，则跳过该关键词的相关度，否则计算时会有除0错误，或者计算出来的数为NaN。</li></ul><blockquote><p>网页文档间以换页符\f分隔。</p></blockquote><ul><li>换页符只出现在网页文档间，即最后一篇文档后是没有换页符的。</li></ul><blockquote><p>输入串K1 K2 … Km中的停用词及非字典中单词将不进行相关度分析。</p></blockquote><ul><li><p>若关键词中有停用词或者非字典词，不应该带入计算，简而言之，有没有这个关键词对结果不影响</p><ul><li><p>可以试试 <code>search 100 yourselves edu news article</code>这组命令行输入，因为yourselves是停用词，所以结果应与样例一致</p></li><li><p>同时还要注意判断关键词是否是字典词()</p></li></ul></li><li><p>页数格式为’数字-数字’，可以用两个数字变量存储，或者直接按字符串读入</p></li></ul><h2 id="细节问题"><a class="markdownIt-Anchor" href="#细节问题"></a> 细节问题</h2><h3 id="读入"><a class="markdownIt-Anchor" href="#读入"></a> 读入</h3><ul><li>用<code>fgetc</code>读入字符时，一定要用<code>int</code>型的变量存储</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> c;<br><span class="hljs-keyword">while</span>(c = fgetc(in)) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>读入字典词或关键词时，注意最后一个词有没有读入(用<code>fscanf()</code>读入时不需要考虑这个问题)</li><li>检查最后一篇文章有没有读入和处理，因为最后一篇文章后没有换页符</li><li>如果用<code>fgets</code>读标题行，一定要确定读的那一行是标题行，以下是错误示范</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\f&#x27;</span>) &#123;<br>fgetc(in);<span class="hljs-comment">// 读取换行符</span><br>fgets(...)<span class="hljs-comment">// 读取标题行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下仅供参考</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\f&#x27;</span>) &#123;<br>    <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c = fgetc(in)));<br>    ungetc(c, in);<br>    fgets(...);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用<code>fread</code>读入时要保存长度，并保证结束处有结束符，在处理时要保证不超过文章长度，以下仅供参考</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> leng;<br>FILE *art = fopen(<span class="hljs-string">&quot;article.txt&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>fseek(art, <span class="hljs-number">0L</span>, SEEK_END);<br>leng = ftell(art);<br>Art = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * (leng + <span class="hljs-number">1</span>));<br>fseek(art, <span class="hljs-number">0L</span>, SEEK_SET);<br>fread(Art, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), leng + <span class="hljs-number">1</span>, art);<br>Art[leng] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; leng; i++) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理"><a class="markdownIt-Anchor" href="#处理"></a> 处理</h3><ul><li>数组的大小要仔细考量，或者开到一定大小保证不会越界，或者在访问数组前判断下标是否越界</li><li>注意数组存储下标的一致性，以下仅供参考</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>&#123;<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\f&#x27;</span>) &#123;<br>        <span class="hljs-comment">// do something</span><br>        cnt++;<br>    &#125;<br>&#125;<br>&#123;<br>    <span class="hljs-comment">// do something for the last article</span><br>&#125;<br>qsort(arr + <span class="hljs-number">1</span>, cnt, <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">1</span>]), cmp);<br></code></pre></td></tr></table></figure><ul><li>注意浮点数的计算和比较，以下也仅供参考</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *v1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *v2)</span> &#123;<br>    Nodeptr n1 = (Nodeptr)v1, n2 = (Nodeptr)v2;<br>    <span class="hljs-keyword">if</span>(n1-&gt;sim - n2-&gt;sim &gt; eps) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n2-&gt;sim - n1-&gt;sim &gt; eps) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n1-&gt;id - n2-&gt;id;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据规模"><a class="markdownIt-Anchor" href="#数据规模"></a> 数据规模</h2><h3 id="停用词文件"><a class="markdownIt-Anchor" href="#停用词文件"></a> 停用词文件</h3><ul><li>单词个数：320</li><li>最长单词长度：12</li></ul><h3 id="字典文件"><a class="markdownIt-Anchor" href="#字典文件"></a> 字典文件</h3><ul><li>单词个数：不超过42w</li><li>最长单词长度：小于50</li></ul><h3 id="小"><a class="markdownIt-Anchor" href="#小"></a> 小</h3><ul><li>单词总个数：不超过42w</li><li>不同单词数：小于1.5w</li><li>最长单词长度：小于80</li><li>网页数：1k</li><li>测试点1命令：<code>100 edu news article</code></li><li>测试点2命令：<code>100 apt and node or whale nnnnn</code></li></ul><h3 id="大"><a class="markdownIt-Anchor" href="#大"></a> 大</h3><ul><li>单词总个数：不超过550w</li><li>不同单词数：小于5w</li><li>最长单词长度：小于80</li><li>网页数：1.6w</li><li>关键词个数：少于100（大胆点，应该是10个左右）</li></ul><h2 id="不同数据点考到的细节"><a class="markdownIt-Anchor" href="#不同数据点考到的细节"></a> 不同数据点考到的细节</h2><p>这里的意思是，过了其中两个点，而剩下一个点输出错误时，没有考虑到的问题</p><h3 id="小-1"><a class="markdownIt-Anchor" href="#小-1"></a> 小-1</h3><p>这个点和样例是一样的</p><h3 id="小-2"><a class="markdownIt-Anchor" href="#小-2"></a> 小-2</h3><ul><li><p>输出了<code>sim</code>值为0的文章</p></li><li><p>没有考虑关键词中出现的停用词</p></li></ul><h3 id="大-2"><a class="markdownIt-Anchor" href="#大-2"></a> 大</h3><ul><li><p>用<code>fgetc()</code>读入时没有用<code>int</code>变量存储</p></li><li><p>用<code>fread()</code>读入时没有设置长度和结束符（见读入部分对<code>fread</code>的处理）</p></li><li><p>用<code>fgets()</code>读入时…建议还是不要用<code>fgets()</code>，用以上两种方法皆可</p></li><li><p>输出时网页序号和标识号的问题</p><ul><li>标识号不一定是<code>1-N</code>的格式，如果是这样的话，那么读标识号将没有任何意义，小数据中符合这个规则只是因为网页数量较少</li><li>序号与标识号右端数字不一定等价，例如<code>1-1000</code>后的文章可能从<code>2-1</code>开始标号</li></ul></li></ul><h2 id="如果本地正确但小数据点全错"><a class="markdownIt-Anchor" href="#如果本地正确但小数据点全错"></a> 如果本地正确，但小数据点全错</h2><ul><li><p>检查输入文件名<code>article.txt, stopwords.txt, dictionary.txt</code></p></li><li><p>检查输出文件名<code>results.txt</code></p></li><li><p>检查是否是命令行输入，以及参数位置是否正确</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab03</title>
    <link href="/2022/04/26/Lab03/"/>
    <url>/2022/04/26/Lab03/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h1><h2 id="thinking-31"><a class="markdownIt-Anchor" href="#thinking-31"></a> thinking 3.1</h2><p>MOS中目前使用的<code>envid</code>是由三部分构成：</p><ul><li>第0-9位：当前进程在<code>envs</code>数组中偏移量，因为共有1024个<code>env</code>，故这部分占据10位</li><li>第10位：1</li><li>第11-16位：6位的<code>ASID</code></li></ul><p>低10位是不会出错的，这一步需要判断高7位是否符合<code>envid</code>的规则，以及<code>ASID</code>是否和低10位偏移量对应。</p><h2 id="thinking-32"><a class="markdownIt-Anchor" href="#thinking-32"></a> thinking 3.2</h2><ul><li><p>UTOP以下的区域是可读写区域，UTOP-ULIM间的区域是只读区域</p></li><li><p>自映射：</p><ul><li><code>UVPT</code>以上到<code>ULIM</code>之间，是一个4MB的空间，正好满足对整个4GB进程空间的自映射。</li><li>在根据页目录，以这4MB空间内的虚拟地址访问页表时，得到的<code>env_cr3</code>正是</li></ul></li><li><p>物理地址和虚拟地址：</p><ul><li>在MOS中，物理内存为64MB，这是所有进程共享的</li><li>对于<code>kuseg, kseg0</code>部分虚拟地址的访问，最终都是落到了访问对应的物理地址。物理地址是真正存储数据的地方</li><li>32位操作系统，虚拟内存共4GB，分为用户空间和内核空间。其中<code>kuseg</code>是用户空间，共2GB；<code>kseg0</code>是内核空间的一部分，也是内核空间中我们目前接触最多的部分，其大小为512MB</li><li>在<code>kuseg</code>空间中，通过二级页表机制将虚拟地址映射到不同的物理页；在<code>kseg0</code>空间中，通过将最高位抹去，直接映射到固定的物理页</li><li>所有进程共享内核所在的2GB空间</li></ul></li></ul><h2 id="thinking-33"><a class="markdownIt-Anchor" href="#thinking-33"></a> thinking 3.3</h2><p><code>user_data</code>为调用<code>load_icode</code>函数时传入的进程参数<code>e</code></p><h2 id="thinking-34"><a class="markdownIt-Anchor" href="#thinking-34"></a> thinking 3.4</h2><p>根据<code>va</code>和<code>va + bin_size</code>是否页对齐，可以分为四种情况：</p><ul><li><p><code>va</code>为页对齐，这种情况较为简单</p></li><li><p><code>va</code>不是页对齐，其中<code>offset = va - ROUNDDOWN(va, BY2PG)</code>，则从<code>va--ROUND(va, BY2PG)</code>这段区间需要单独加载，首先需要考虑<code>va</code>是否和物理页面有映射关系，如果有，则需要找到对应的物理页面；否则需要分配一个新的物理页</p><p><img src="/img/Lab03/4.1.jpg" alt="" /></p></li><li><p><code>va + bin_size</code>为页对齐</p></li><li><p><code>va + bin_size</code>非页对齐，此时<code>offset = va + i - ROUNDDOWN(va + i, BY2PG)</code>，则从<code>ROUNDDOWN(va + i, BY2PG)--va + i</code>这段区间需要单独加载，即用offset代替BY2PG作为加载的size</p><p><img src="/img/Lab03/4.2.jpg" alt="" /></p></li></ul><h2 id="thinking-35"><a class="markdownIt-Anchor" href="#thinking-35"></a> thinking 3.5</h2><ul><li><p>虚拟地址。</p></li><li><p>每个进程不一样。</p></li><li><blockquote><p><code>e_entry</code>：此字段指明程序入口的虚拟地址。即当文件被加载到进程空间里后，入口程序在进程地址空间里的地址。对于可执行程序文件来说，当 ELF 文件完成加载之 后，程序将从这里开始运行；而对于其它文件来说，这个值应该是 0。</p></blockquote></li></ul><h2 id="thinking-36"><a class="markdownIt-Anchor" href="#thinking-36"></a> thinking 3.6</h2><p><code>epc</code>是<code>CP0</code>寄存器组中记录异常发生地址的寄存器。在发生中断时，<code>CPU</code>会将发生中断的地址存入该寄存器。</p><p>在<code>env_pop_tf()</code>函数中，最后会跳转到进程的<code>pc</code>寄存器，但是在进程切换中，实际跳转的地方应该是<code>epc</code>寄存器，故要将<code>pc</code>寄存器中的值设置为<code>epc</code>。</p><h2 id="thinking-37"><a class="markdownIt-Anchor" href="#thinking-37"></a> thinking 3.7</h2><ul><li>在宏<code>SAVE_ALL</code>中，将当前进程的上下文存到<code>TIMESTACK</code></li><li>是内核区域中不同的栈区域，当出现时钟中断时，存储的区域为<code>TIMESTACK</code>，对于其它异常，存储区域为<code>KERNEL_SP</code></li></ul><h2 id="thinking-38"><a class="markdownIt-Anchor" href="#thinking-38"></a> thinking 3.8</h2><ul><li><code>handle_int: lib/genex.S</code></li><li><code>handle_mod, handle_tlb: lib/genex.S</code>，抽象成了函数<code>handle_\exception</code></li><li><code>handle_sys: lib/syscall.S</code></li></ul><h2 id="thinking-39"><a class="markdownIt-Anchor" href="#thinking-39"></a> thinking 3.9</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">.macro  setup_c0_status set clr<br>//定义了一个宏，将状态寄存器修改为设定值，若clr置1则清零<br>.set    push<br>    mfc0    t0, CP0_STATUS<br>    or      t0, \set|\clr<br>    xor     t0, \clr<br>    mtc0    t0, CP0_STATUS<br>    .set    pop<br>.endm<br><br>LEAF(set_timer)<br>        li t0, 0xc8//t0 &lt;- 200<br>        sb t0, 0xb5000100//将时钟中断设置为200次<br>        sw sp, KERNEL_SP//KERNEL_SP &lt;- sp, 将当前栈内容存入内核栈指针处<br>setup_c0_status STATUS_CU0|0x1001 0//CP0_STATUS &lt;- STATUS_CU0|0x1001=0x10001001<br>        jr ra//<br>        nop<br>END(set_timer)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">timer_irq:<br>sb zero, 0xb5000110//关闭时钟中断<br>1:  j       sched_yield//调用sched_yield函数<br>    nop<br>    /*li t1, 0xff<br>    lw    t0, delay<br>    addu  t0, 1<br>    sw      t0, delay<br>    beq     t0,t1,1f<br>    nop*/<br>    j       ret_from_exception//调用ret_from_exception函数<br>    nop<br></code></pre></td></tr></table></figure><h2 id="thinking-310"><a class="markdownIt-Anchor" href="#thinking-310"></a> thinking 3.10</h2><img src="/img/Lab03/异常处理.png" style="zoom:150%;" /><p>当发生时钟中断，先通过<code>except_vec3</code>异常分发进入对应处理异常函数，在本次实验中为中断处理函数<code>handle_int</code>。然后通过一些处理，比如保存现场等，之后通过判断中断码进入相应的中断服务函数，本次实验中为<code>timer_irq</code>。在该函数中主要工作为调用<code>sched_yield</code>函数调度进程，在该函数中会通过进程的优先级切换进程并运行，这便是根据时钟周期切换进程。</p><h1 id="实验难点"><a class="markdownIt-Anchor" href="#实验难点"></a> 实验难点</h1><h2 id="进程创建流程及函数调用图"><a class="markdownIt-Anchor" href="#进程创建流程及函数调用图"></a> 进程创建流程及函数调用图</h2><p><img src="/img/Lab03/env_create.png" alt="" /></p><h2 id="进程创建相关函数"><a class="markdownIt-Anchor" href="#进程创建相关函数"></a> 进程创建相关函数</h2><h3 id="env_create"><a class="markdownIt-Anchor" href="#env_create"></a> <code>env_create</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：创建进程</p><h3 id="env_create_priority"><a class="markdownIt-Anchor" href="#env_create_priority"></a> <code>env_create_priority</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：创建进程</p><h3 id="env_alloc"><a class="markdownIt-Anchor" href="#env_alloc"></a> <code>env_alloc</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：</p><ul><li>调用<code>env_setup_vm</code>函数，为进程分配页目录并完成部分映射</li><li>初始化对应PCB，主要包括<code>env_id, env_parent_id, env_status, env_runs, env_tf.cp0_status, env_tf.regs[29]</code></li><li>将进程从空闲链表中移出，加入调度队列(这和物理内存管理的页链表管理体系很类似)</li></ul><h3 id="env_setup_vm"><a class="markdownIt-Anchor" href="#env_setup_vm"></a> <code>env_setup_vm</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：</p><ul><li><p>为进程的页目录分配物理页</p></li><li><p>以<code>UTOP</code>为界，将用户空间分别映射，映射的模板是之前虚拟内存初始化时得到的<code>boot_pgdir</code></p><ul><li><p><code>0--UTOP</code>间的用户空间是可读写的，且各个进程在这部分的内容是各不一样的，因此在该函数中我们将其全部清零</p></li><li><p><code>UTOP--UTPV</code>间的用户空间是存储<code>pages, envs</code>结构体数组的，这也是在之前虚拟内存初始化时完成映射的，这样在用户空间就可以访问到这两个数组。这部分对于所有进程都是相同的，因此我们以<code>boot_pgdir</code>为模板完成映射</p></li><li><p><code>UVPT--UTOP</code>间的用户空间是用来自映射的，这部分4MB空间正好可以映射整个4GB虚拟内存空间，我们用以下代码来初始化这块空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">e-&gt;env_pgdir = pgdir;<br>e-&gt;env_cr3 = PADDR(e-&gt;env_pgdir);<br>e-&gt;env_pgdir[PDX(UVPT)] = e-&gt;env_cr3 | PTE_V;<br></code></pre></td></tr></table></figure></li><li><p><code>UTOP</code>以上的空间不属于用户空间，也是用户态无法访问的内存空间</p></li></ul></li></ul><h2 id="进程加载相关函数"><a class="markdownIt-Anchor" href="#进程加载相关函数"></a> 进程加载相关函数</h2><h3 id="load_icode"><a class="markdownIt-Anchor" href="#load_icode"></a> <code>load_icode</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：</p><ul><li>分配物理页，并完成从用户栈空间到该物理页的映射</li><li>通过<code>load_elf</code>函数完成文件二进制数据到用户空间的映射</li><li>设置进程的入口，该入口地址通过上面的<code>load_elf</code>函数获得</li></ul><h3 id="load_elf"><a class="markdownIt-Anchor" href="#load_elf"></a> <code>load_elf</code></h3><p><strong>位置</strong>：<code>lib/kernel_elfloader.c</code></p><p><strong>说明</strong>：分段调用<code>load_icode_mapper</code>函数完成映射</p><h3 id="is_elf_format"><a class="markdownIt-Anchor" href="#is_elf_format"></a> <code>is_elf_format</code></h3><p><strong>位置</strong>：<code>lib/kernel_elfloader.c</code></p><p><strong>说明</strong>：判断文件是否符合<code>ELF</code>文件格式</p><h3 id="load_icode_mapper"><a class="markdownIt-Anchor" href="#load_icode_mapper"></a> <code>load_icode_mapper</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：将文件二进制数据映射到用户空间</p><h2 id="时钟中断处理图"><a class="markdownIt-Anchor" href="#时钟中断处理图"></a> 时钟中断处理图</h2><img src="/img/Lab03/异常处理.png" style="zoom:150%;" /><h2 id="异常处理相关函数"><a class="markdownIt-Anchor" href="#异常处理相关函数"></a> 异常处理相关函数</h2><h3 id="except_vec3"><a class="markdownIt-Anchor" href="#except_vec3"></a> <code>except_vec3</code></h3><p><strong>位置</strong>：<code>boot/start.S</code></p><p><strong>说明</strong>：负责异常分发，根据状态寄存器的<code>ExCode</code>跳转到对应的异常处理函数</p><h3 id="handle_exception"><a class="markdownIt-Anchor" href="#handle_exception"></a> <code>handle_\exception</code></h3><p><strong>位置</strong>：<code>lib/genex.S</code></p><p><strong>说明</strong>：异常处理函数</p><h3 id="timer_irq"><a class="markdownIt-Anchor" href="#timer_irq"></a> <code>timer_irq</code></h3><p><strong>位置</strong>：<code>lib/genex.S</code></p><p><strong>说明</strong>：时钟中断的处理函数</p><h3 id="sched_yield"><a class="markdownIt-Anchor" href="#sched_yield"></a> <code>sched_yield</code></h3><p><strong>位置</strong>：<code>lib/sched.c</code></p><p><strong>说明</strong>：调度函数</p><h3 id="env_run"><a class="markdownIt-Anchor" href="#env_run"></a> <code>env_run</code></h3><p><strong>位置</strong>：<code>lib/env.c</code></p><p><strong>说明</strong>：运行进程</p><h3 id="ret_from_exception"><a class="markdownIt-Anchor" href="#ret_from_exception"></a> <code>ret_from_exception</code></h3><p><strong>位置</strong>：<code>lib/genex.S</code></p><p><strong>说明</strong>：恢复现场</p><h2 id="异常处理相关宏定义"><a class="markdownIt-Anchor" href="#异常处理相关宏定义"></a> 异常处理相关宏定义</h2><h3 id="save_all"><a class="markdownIt-Anchor" href="#save_all"></a> <code>SAVE_ALL</code></h3><p><strong>位置</strong>：<code>include/stackframe.h</code></p><p><strong>位置</strong>：<code>boot/start.S</code></p><p><strong>说明</strong>：保存现场</p><h3 id="restore_someall"><a class="markdownIt-Anchor" href="#restore_someall"></a> <code>RESTORE_SOME/ALL</code></h3><p><strong>位置</strong>：<code>include/stackframe.h</code></p><p><strong>说明</strong>：恢复现场</p><h3 id="get_sp"><a class="markdownIt-Anchor" href="#get_sp"></a> <code>get_sp</code></h3><p><strong>位置</strong>：<code>include/stackframe.h</code></p><p><strong>说明</strong>：获取保存现场的栈指针</p><h3 id="sti"><a class="markdownIt-Anchor" href="#sti"></a> <code>STI</code></h3><p><strong>位置</strong>：<code>include/stackframe.h</code></p><p><strong>说明</strong>：开启全局中断使能</p><h3 id="cli"><a class="markdownIt-Anchor" href="#cli"></a> <code>CLI</code></h3><p><strong>位置</strong>：<code>include/stackframe.h</code></p><p><strong>说明</strong>：禁用全局中断</p><h1 id="总结与反思"><a class="markdownIt-Anchor" href="#总结与反思"></a> 总结与反思</h1><p>本次实验重点就是进程的创建和调度，以及简单异常的处理。</p><p>相关函数相比之前增加了很多，导致理清函数的调用关系成为了一个重点和前提，否则难以理清逻辑，更别谈去完成所有的函数了。</p><p>因此在反复学习指导书和阅读代码之后，在自己理解的基础上画了两个思维导图，以理清逻辑关系。</p>]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab02</title>
    <link href="/2022/04/15/Lab02/"/>
    <url>/2022/04/15/Lab02/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h1><h2 id="thinking-21"><a class="markdownIt-Anchor" href="#thinking-21"></a> thinking 2.1</h2><p>1.虚拟地址</p><p>2.虚拟地址</p><h2 id="thinking-22"><a class="markdownIt-Anchor" href="#thinking-22"></a> thinking 2.2</h2><p>1.使用宏实现链表，不仅可以实现空页的链表管理，也可以实现空进程的链表管理。使用同一套宏可以实现多个链表的管理，大大提高了可重用性。</p><p>2.性能：</p><ol><li>单向链表</li></ol><p>​插入操作相对较为简单，因为不需要维护<code>le_prev</code>指针，但是性能相差不大</p><p>​删除操作单向链表更复杂，时间复杂度为<code>O(n)</code>，双向链表复杂度为<code>O(1)</code></p><ol start="2"><li>循环链表</li></ol><p>​插入操作简单，可以在<code>O(1)</code>时间内插入链表尾部，双向链表插入尾部复杂度为<code>O(n)</code></p><p>​删除操作与单向链表相同，时间复杂度为<code>O(n)</code></p><h2 id="thinking-23"><a class="markdownIt-Anchor" href="#thinking-23"></a> thinking 2.3</h2><p>C：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">le_next</span>;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> **<span class="hljs-title">le_prev</span>;</span><br>        &#125; pp_link;<br>        u_short pp_ref;<br>    &#125;* lh_first;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thinking-24"><a class="markdownIt-Anchor" href="#thinking-24"></a> thinking 2.4</h2><p><code>boot_map_segment()</code>：</p><p><code>boot_map_segment(pgdir, PAGES, n, PADDR(pages), PTE_R);</code></p><p><code>boot_map_segment(pgdir, ENVS, n, PADDR(envs), PTE_R);</code></p><p>在<code>mips_vm_init()</code>中被调用了两次，分别将<code>pages</code>数组的物理地址映射到以虚拟地址<code>UPAGE</code>为起始地址的内核页表，以及将<code>envs</code>数组的物理地址映射到以虚拟地址<code>UENV</code>为起始地址的内核页表。</p><p><code>boot_pgdir_walk</code>：</p><p><code>pgtable_entry = boot_pgdir_walk(pgdir, va_temp, 1);</code></p><p>由<code>boot_map_segment</code>调用。</p><h2 id="thinking-25"><a class="markdownIt-Anchor" href="#thinking-25"></a> thinking 2.5</h2><p>1.ASID：</p><p>在不同的进程中，有一部分虚拟内存是所有进程共享的，因此相同的虚拟内存，在不同的进程中回映射到不同的物理地址。为了区分不同进程的虚拟地址，引入了不同进程互不相同的ASID，在查找TLB时，需要传入虚地址和对应的ASID，这样才能正确查找到对应的物理地址。因此ASID是不可缺少的。</p><p>2.在不刷新旧的ASID值情况下，由于EntryHi寄存器中ASID值共6位，因此最多可以容纳64个不同的地址空间。</p><h2 id="thinking-26"><a class="markdownIt-Anchor" href="#thinking-26"></a> thinking 2.6</h2><ol><li></li></ol><p><code>tlb_invalidate</code>调用<code>tlb_out</code></p><ol start="2"><li></li></ol><p>根据当前进程的状态，以虚拟地址和进程的<code>ASID</code>值为参数调用<code>tlb_out</code>完成对<code>TLB</code>对应内容的清除</p><ol start="3"><li></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">LEAF(tlb_out)<br>        mfc0    k1,CP0_ENTRYHI//$k1 = $EntryHi，暂时保存原EntryHi寄存器值<br>        mtc0    a0,CP0_ENTRYHI//$EntryHi = $a0, 此时a0为调用tlb_out时传入的参数<br>        nop//空操作<br>        tlbp//tlbp, 根据EntryHi寄存器中的值查找对应的表项，并存入Index寄存器<br>        nop<br>        nop<br>        nop<br>        nop//空操作, tlbp需要的时钟数<br>        mfc0    k0,CP0_INDEX//$k0 = $Index<br>        bltz    k0,NOFOUND//if $k0 &lt; 0, 即Index寄存器最高位为1，代表未找到相应页，则跳转到&#x27;NOFOUND&#x27;<br>        nop//空操作<br>        mtc0    zero,CP0_ENTRYHI//$EntryHi = 0<br>        mtc0    zero,CP0_ENTRYLO0//$EntryLo = 0<br>        nop//空操作<br>        tlbwi//tlbwi, 根据Index寄存器中的索引将对应的EntryHi和EntryLo清零<br>NOFOUND:<br>        mtc0    k1,CP0_ENTRYHI//$EntryHi = $k1，将原EntryHi寄存器值写回<br><br>        j       ra//结束函数，返回<br>        nop//空操作<br>END(tlb_out)<br></code></pre></td></tr></table></figure><h2 id="thinking-27"><a class="markdownIt-Anchor" href="#thinking-27"></a> thinking 2.7</h2><p><code>PTbase</code>对应第<code>PTbase&gt;&gt;12</code>个页表项，每个页表项大小为<code>8B</code>，则偏移地址为<code>(PTbase&gt;&gt;12)&lt;&lt;3</code>，</p><p>则二级页表基地址为<code>PTbase|(PTbase&gt;&gt;12)&lt;&lt;3</code>。</p><p>同理可得，页目录基地址为<code>PTbase|(PTbase&gt;&gt;12)&lt;&lt;3|(PTbase&gt;&gt;21)&lt;&lt;3</code>，</p><p>而映射到页目录自身的页目录项地址为<code>PTbase|(PTbase&gt;&gt;12)&lt;&lt;3|(PTbase&gt;&gt;21)&lt;&lt;3|(PTbase&gt;&gt;30)&lt;&lt;3</code>。</p><h2 id="thinking-28"><a class="markdownIt-Anchor" href="#thinking-28"></a> thinking 2.8</h2><p>x86架构的内存管理分为两个部分，分段和分页。</p><p>分段提供了一种隔离每个进程或者任务代码、数据和栈模块的机制，保证多个进程或者任务能够在同一个处理器上运行而不会互相干扰。</p><p>分页机制实现了传统请求调页的虚拟内存系统，在这种系统中，程序的执行环境块按需要被映射到物理内存中。分页机制同样可以用来隔离多个任务。</p><p>对分页和分段机制进行不同的配置，可以分别支持简单的单任务系统、多任务系统或者使用共享内存的多处理器系统。</p><p>x86用到三个地址空间的概念：物理地址、线性地址和逻辑地址。而MIPS只有物理地址和虚拟地址两个概念。</p><h1 id="实验难点"><a class="markdownIt-Anchor" href="#实验难点"></a> 实验难点</h1><h2 id="物理内存管理"><a class="markdownIt-Anchor" href="#物理内存管理"></a> 物理内存管理</h2><h3 id="页式内存管理"><a class="markdownIt-Anchor" href="#页式内存管理"></a> 页式内存管理</h3><p>MOS结构中采取页式管理结构，将物理内存总64MB按4KB一页分成16K页。</p><p>在物理内存管理中，通过<code>pages</code>结构体数组对这16K页进行管理。</p><p><code>Page</code>结构体中并没有记录太多复杂的信息，其中<code>pp_ref</code>记录了该物理内被映射的次数，<code>pp_link</code>是为了后续采取链表结构管理空闲链表所定义。每个<code>Page</code>结构体对应的物理页并不需要记录，因为结构体与物理页一一对应，通过<code>(p - pages)&lt;&lt;12</code>即可计算得到。</p><h3 id="链表管理空闲内存"><a class="markdownIt-Anchor" href="#链表管理空闲内存"></a> 链表管理空闲内存</h3><h4 id="宏定义"><a class="markdownIt-Anchor" href="#宏定义"></a> 宏定义</h4><p>对于空闲链表，MOS采取链表结构管理，并定义了一系列的宏便于操作。</p><p>理解并应用链表宏是物理内存管理的难点，下面把一些常用或者较为重要宏里的参数用<code>Page</code>结构体对应的变量代换以便于理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">LIST_HEAD(Page_list, Page)<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">lh_first</span>;</span><br>&#125;<br><span class="hljs-comment">//定义了一个Page_list结构体类型</span><br>LIST_ENTRY(Page)<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">le_next</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> **<span class="hljs-title">le_prev</span>;</span><br>&#125;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">LIST_ENTRY</span><span class="hljs-params">(Page)</span> Page_LIST_entry_t;<br><span class="hljs-comment">//定义了用于链表管理的page_entry</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>    Page_LIST_entry_t pp_link;<br>    u_short pp_ref;<br>&#125;<br><span class="hljs-comment">//定义了Page结构体</span><br>LIST_NEXT((page), pp_link)<br>page-&gt;pp_link.le_next<br></code></pre></td></tr></table></figure><p>通过转换以后可以很容易得到用于管理空闲链表的结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">le_next</span>;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> **<span class="hljs-title">le_prev</span>;</span><br>        &#125; pp_link;<br>        u_short pp_ref;<br>    &#125;* lh_first;<br>&#125;<br><span class="hljs-type">static</span> Page_list free_page_list;<br></code></pre></td></tr></table></figure><h4 id="宏函数"><a class="markdownIt-Anchor" href="#宏函数"></a> 宏函数</h4><p>在了解了数据结构以后，便可以着手编写宏函数了。</p><h5 id="list_insert_after"><a class="markdownIt-Anchor" href="#list_insert_after"></a> LIST_INSERT_AFTER</h5><p>由于双向链表的结构，<code>LIST_INSERT_AFTER(listelm, elm, field)</code>的实现并不难，先了解三个参数对应的含义：</p><ul><li><code>listelm</code>为链表中的元素，即用于定位的元素，在此函数中，新的元素需要被插入到该元素之后</li><li><code>elm</code>即为新的需要被插入到链表中的元素</li><li><code>field</code>是定义的用于链表管理的<code>entry</code>，在链表管理中，即为<code>Page</code>结构体中的<code>pp_link</code></li></ul><p>同样为了便于理解，把宏里的参数用<code>Page</code>结构体对应的变量代换得到代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">LIST_INSERT_AFTER(listpage, page, pp_link) <span class="hljs-keyword">do</span> &#123;     \<br>    LIST_NEXT((page), pp_link) = LIST_NEXT((listpage), pp_link);\<br><span class="hljs-keyword">if</span>(LIST_NEXT((listpage), pp_link) != <span class="hljs-literal">NULL</span>) \<br>        LIST_NEXT((listpage), pp_link)-&gt;pp_link.le_prev = &amp;LIST_NEXT((page), pp_link);  \<br>    LIST_NEXT((listpage), pp_link) = (page); \<br>(page)-&gt;pp_link.le_prev = &amp;LIST_NEXT((listpage), pp_link);\<br>&#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)                                                       <br></code></pre></td></tr></table></figure><p>如图所示:</p><p><img src="/img/Lab02/InkedLIST_INSERT_AFTER_LI.jpg" alt="" /></p><h5 id="list_insert_tail"><a class="markdownIt-Anchor" href="#list_insert_tail"></a> LIST_INSERT_TAIL</h5><p>这个相对于前一个函数复杂的地方在于，首先需要判断链表是否为空，若非空则需要从头指针遍历直到最后一个节点，然后再仿照前一个函数将新元素插入尾部元素之后。而遍历是需要循环变量的，在编写这个函数时以为不可以在宏里定义新的变量，因此用<code>LIST_NEXT((page), pp_link)</code>作为循环变量，代换后代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INSERT_TAIL(head, page, pp_link) do &#123;                                    \</span><br><span class="hljs-meta"><span class="hljs-keyword">if</span> ((LIST_FIRST((head)) == NULL)) LIST_INSERT_HEAD(head, page, pp_link);   \</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span> &#123;                                                                  \</span><br><span class="hljs-meta">LIST_NEXT((page), pp_link) = LIST_FIRST((head));                               \</span><br><span class="hljs-meta">while (LIST_NEXT((LIST_NEXT((page), pp_link)), pp_link) != NULL) &#123;               \</span><br><span class="hljs-meta">LIST_NEXT((page), pp_link) = LIST_NEXT((LIST_NEXT((page), pp_link)), pp_link);  \</span><br><span class="hljs-meta">&#125; \</span><br><span class="hljs-meta">LIST_NEXT(LIST_NEXT((page), pp_link), pp_link) = (page);                          \</span><br><span class="hljs-meta">(page)-&gt;pp_link.le_prev = &amp;LIST_NEXT(LIST_NEXT((page), pp_link), pp_link);      \</span><br><span class="hljs-meta">LIST_NEXT((page), pp_link) = NULL;                                         \</span><br><span class="hljs-meta">&#125;                       \</span><br><span class="hljs-meta">&#125; while (0)</span><br></code></pre></td></tr></table></figure><blockquote><p>在写这个函数的时候有一个小问题，在找到最后一个元素后调用<code>LIST_INSERT_AFTER</code>会出错，应该是尾部元素之后的空指针导致的，但是具体问题还是没有发现。</p></blockquote><h4 id="相关函数"><a class="markdownIt-Anchor" href="#相关函数"></a> 相关函数</h4><p>主要是<code>page_init(), page_alloc(), page_free()</code>三个函数，在理解和编写完宏函数之后，以及指导书中给定框架的帮助下，这些函数并不难完成。</p><p><strong>需要注意的是</strong>，调用<code>page_alloc()</code>后，通常需要给新的<code>Page</code>的<code>pp_ref++</code>；而调用<code>page_free()</code>前，需要给该<code>Page</code>的<code>pp_ref--</code>。</p><h2 id="虚拟内存管理"><a class="markdownIt-Anchor" href="#虚拟内存管理"></a> 虚拟内存管理</h2><blockquote><p>在 R3000 上，虚拟地址映射到物理地址，随后使用物理地址来访存。与我们实验相关的映射与寻址规则（内存布局）如下：</p><ul><li>若虚拟地址处于 0x80000000~0x9fffffff (kseg0)，则将虚拟地址的最高位置 0得到物理地址，通过 cache 访存。这一部分用于存放内核代码与数据结构。</li><li>若虚拟地址处于 0xa0000000~0xbfffffff (kseg1)，则将虚拟地址的最高 3 位置0 得到物理地址，不通过 cache 访存。这一部分用于映射外设。</li><li>若虚拟地址处于 0x00000000~0x7fffffff (kuseg)，则需要通过 TLB 来获取物理地址，通过 cache 访存。</li></ul></blockquote><h3 id="kseg0"><a class="markdownIt-Anchor" href="#kseg0"></a> kseg0</h3><p>对于处于<code>kseg0</code>内的虚拟地址，我们可以直接用如下两个宏来访问对应物理地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PADDR(kva)                                                      \</span><br><span class="hljs-meta">    (&#123;                                                                  \</span><br><span class="hljs-meta">        u_long a = (u_long)(kva);                                       \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (a &lt; ULIM)                        \</span><br><span class="hljs-meta">            panic(<span class="hljs-string">&quot;PADDR called with invalid kva %08lx&quot;</span>, a);            \</span><br><span class="hljs-meta">        a - ULIM;                                                       \</span><br><span class="hljs-meta">    &#125;)</span><br><span class="hljs-comment">//ULIM = 0x80000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KADDR(pa)                                                       \</span><br><span class="hljs-meta">    (&#123;                                                                  \</span><br><span class="hljs-meta">        u_long ppn = PPN(pa);   \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (ppn &gt;= npage)                         \</span><br><span class="hljs-meta">            panic(<span class="hljs-string">&quot;KADDR called with invalid pa %08lx&quot;</span>, (u_long)(pa));  \</span><br><span class="hljs-meta">        (pa) + ULIM;                                                    \</span><br><span class="hljs-meta">    &#125;)</span><br></code></pre></td></tr></table></figure><p>可以看到，在该区间内的虚拟和物理地址映射较为简单，就是最高位置1置0的区别。在转换之前，是有判断机制的，即<code>kva</code>应当大于<code>0x80000000</code>，否则不能使用该宏转换；<code>pa</code>对应的物理页框不能大于<code>npage</code>，其本质也就是<code>pa</code>要小于最大物理内存<code>64MB</code>，否则这个物理地址也是不合法的。</p><p>而我们的实验重点在于<code>kuseg</code>段，需要填写二级页表，并通过<code>TLB</code>来访问物理地址。</p><h3 id="kuseg"><a class="markdownIt-Anchor" href="#kuseg"></a> kuseg</h3><h4 id="二级页表的填写"><a class="markdownIt-Anchor" href="#二级页表的填写"></a> 二级页表的填写</h4><p>这是虚拟内存管理的重点，也是个人认为整个lab2中<strong>最难</strong>的部分。涉及到二级页表的相关知识，以及虚拟地址和物理地址的区别和联系。</p><p>首先借助指导书中的图便于理解二级页表的结构：</p><p><img src="/img/Lab02/pgdir.jpg" alt="" /></p><p>整个二级页表的填写分为两个部分，使用两套配对的函数，时间分界点在于<code>page_init()</code>，但是整体过程是类似的：</p><ul><li>有变量<code>va, pa, pgdir, pgdir_entry, pgtable, pgtable_entry</code>，对应关系如上图所示，这些变量都是指明对应的地址，并不是地址里存的实际值</li><li>整个填写二级页表的流程大体如下：<ul><li>计算一级页目录入口<code>pgdir_entry = pgdir + PDX(va)</code></li><li>由一级页目录入口获得二级页表基地址<code>pgtable = KADDR(PTE_ADDR(*pgdir))</code></li><li>计算二级页表入口<code>pgtable_entry = pgtable + PTX(va)</code></li><li>为二级页表入口设置对应的物理地址页号<code>*pgtable_entry = PPN(pa) or *pgtable_entry = PPN(page2pa(page))</code></li></ul></li><li>在<code>page_init()</code>函数之前，使用<code>boot_pgdir_walk()</code>和<code>boot_map_segment()</code>函数完成填写，在其之后则使用<code>pgdir_walk()</code>和<code>page_insert()</code>函数完成填写。其中都是由后者调用前者，前者完成图示中的前三步，由后者完成第四步。</li></ul><h4 id="tlb的填写"><a class="markdownIt-Anchor" href="#tlb的填写"></a> TLB的填写</h4><blockquote><p><strong>所有的在低 2GB 空间的访存操作都需要经过 TLB</strong>。</p></blockquote><p>TLB的重填本身是比较复杂的，不过本实验中并没有要求这个内容，只是要求完成<code>tlb_out</code>函数，这在理解TLB重填的过程后并不难，这里就不再展开了。但是理解TLB重填的过程还是十分重要的，在后续的实验中还会多次涉及。</p><h1 id="实验心得与总结"><a class="markdownIt-Anchor" href="#实验心得与总结"></a> 实验心得与总结</h1><p>只能说lab2的难度比lab1又高了一个台阶，开启了真正的地狱模式。</p><p>即使是在lab2课下拿到了满分之后，对于二级页表映射，虚拟地址和物理地址还是不能完全搞明白。</p><p>直到lab3做了一部分以后，可能和lab2对照着看，终于算是理清了头绪。</p>]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab01</title>
    <link href="/2022/04/05/Lab01/"/>
    <url>/2022/04/05/Lab01/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h1><h2 id="thinking11"><a class="markdownIt-Anchor" href="#thinking11"></a> thinking1.1</h2><h3 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h3><p><code>-D : Display assembler contents of all sections</code>，即反汇编所有节的内容</p><p><code>-S : Intermix source code with disassembly</code>，显示与反汇编结合的源代码</p><h3 id="编译与反汇编i"><a class="markdownIt-Anchor" href="#编译与反汇编i"></a> 编译与反汇编Ⅰ</h3><h4 id="mainc"><a class="markdownIt-Anchor" href="#mainc"></a> main.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> c = a + b;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="反汇编maino只截取main代码段"><a class="markdownIt-Anchor" href="#反汇编maino只截取main代码段"></a> 反汇编main.o(只截取main代码段)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">00000000 &lt;main&gt;:<br>    0:   27bdffe0    addiu   sp,sp,-32//8 bytes<br>    4:   afbe0018    sw  s8,24(sp)//store $s8 into stack<br>    8:   03a0f021    move    s8,sp//store $sp into s8<br>    c:   24020001    li  v0,1//$v0 = 1<br>    10:   afc20010    sw  v0,16(s8)//<br>    14:   24020002    li  v0,2<br>    18:   afc2000c    sw  v0,12(s8)<br>    1c:   8fc30010    lw  v1,16(s8)<br>    20:   8fc2000c    lw  v0,12(s8)<br>    24:   00621021    addu    v0,v1,v0<br>    28:   afc20008    sw  v0,8(s8)<br>    2c:   00001021    move    v0,zero<br>    30:   03c0e821    move    sp,s8<br>    34:   8fbe0018    lw  s8,24(sp)<br>    38:   27bd0020    addiu   sp,sp,32<br>    3c:   03e00008    jr  ra<br>    40:   00000000    nop<br></code></pre></td></tr></table></figure><h4 id="反汇编main只截取main代码段"><a class="markdownIt-Anchor" href="#反汇编main只截取main代码段"></a> 反汇编main(只截取main代码段)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">004000b0 &lt;main&gt;:<br>    4000b0:   27bdffe0    addiu   sp,sp,-32<br>    4000b4:   afbe0018    sw  s8,24(sp)<br>    4000b8:   03a0f021    move    s8,sp<br>    4000bc:   24020001    li  v0,1<br>    4000c0:   afc20010    sw  v0,16(s8)<br>    4000c4:   24020002    li  v0,2<br>    4000c8:   afc2000c    sw  v0,12(s8)<br>    4000cc:   8fc30010    lw  v1,16(s8)<br>    4000d0:   8fc2000c    lw  v0,12(s8)<br>    4000d4:   00621021    addu    v0,v1,v0<br>    4000d8:   afc20008    sw  v0,8(s8)<br>    4000dc:   00001021    move    v0,zero<br>    4000e0:   03c0e821    move    sp,s8<br>    4000e4:   8fbe0018    lw  s8,24(sp)<br>    4000e8:   27bd0020    addiu   sp,sp,32<br>    4000ec:   03e00008    jr  ra<br>    4000f0:   00000000    nop<br></code></pre></td></tr></table></figure><p>在链接时进行了重定位，<code>main</code>地址不再是0，而是0x4000b0。</p><h3 id="编译与反汇编ii反汇编vmlinux"><a class="markdownIt-Anchor" href="#编译与反汇编ii反汇编vmlinux"></a> 编译与反汇编Ⅱ——反汇编vmlinux</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">80010040 &lt;main&gt;:<br>    80010040:   27bdffe8    addiu   sp,sp,-24<br>    80010044:   afbf0010    sw  ra,16(sp)<br>    80010048:   3c048001    lui a0,0x8001<br>    8001004c:   0c00428e    jal 80010a38 &lt;printf&gt;<br>    80010050:   24840af8    addiu   a0,a0,2808<br>    80010054:   3c048001    lui a0,0x8001<br>    80010058:   24840b14    addiu   a0,a0,2836<br>    8001005c:   2405000a    li  a1,10<br>    80010060:   3c068001    lui a2,0x8001<br>    80010064:   0c00428e    jal 80010a38 &lt;printf&gt;<br>    80010068:   24c60b1c    addiu   a2,a2,2844<br>    8001006c:   0c004024    jal 80010090 &lt;mips_init&gt;<br>    80010070:   00000000    nop   <br>    80010074:   3c048001    lui a0,0x8001<br>    80010078:   24840b24    addiu   a0,a0,2852<br>    8001007c:   24050014    li  a1,20<br>    80010080:   3c068001    lui a2,0x8001<br>    80010084:   0c00429e    jal 80010a78 &lt;_panic&gt;<br>    80010088:   24c60b2c    addiu   a2,a2,2860<br>    8001008c:   00000000    nop<br></code></pre></td></tr></table></figure><h2 id="thinking12"><a class="markdownIt-Anchor" href="#thinking12"></a> thinking1.2</h2><p>之前的<code>testELF</code>文件是小端编码，而内核文件<code>vmlinux</code>是大端编码，在读取数据时会产生错误，最终导致读取地址越界，因此我们的<code>readELF</code>程序并不能解析。</p><h2 id="thinking13"><a class="markdownIt-Anchor" href="#thinking13"></a> thinking1.3</h2><p>因为在<code>GXemul</code>仿真器的帮助下，我们已经有了完整的C环境，只需要将内核加载后跳转到内核函数入口就可以启动完毕。</p><p>在链接器中，我们指定了内核加载的地址，并通过<code>start</code>中的代码，初始化硬件设备，设置堆栈入口，然后跳转到了内核函数入口处。</p><h2 id="thinking14"><a class="markdownIt-Anchor" href="#thinking14"></a> thinking1.4</h2><p>避免<strong>页面冲突</strong>现象，即两个程序所占空间不能重合；</p><p>避免<strong>页面共享</strong>现象，即两个程序占据了同一页的空间。</p><p>对于当前程序加载时，应当以前一程序的尾地址<strong>向后</strong>页对齐后的地址作为起始地址，即保证两个程序不会占据同一页的空间，避免了页面共享和页面冲突现象。</p><h2 id="thinking15"><a class="markdownIt-Anchor" href="#thinking15"></a> thinking1.5</h2><p>内核入口在<code>0x80010000</code></p><p><code>main</code>函数在<code>0x80010040</code>，从对<code>vmlinux</code>的反汇编中可以看到</p><p>在<code>start.S</code>文件中设置堆栈入口后，通过调用<code>main</code>函数，即<code>MIPS</code>中的<code>jal</code>指令，进入<code>main</code>函数</p><p>通过链接和重定位后，每个函数有自己的地址，可以通过<code>jal</code>进行跨文件调用函数</p><h2 id="thinking16"><a class="markdownIt-Anchor" href="#thinking16"></a> thinking1.6</h2><p>将<code>CP0</code>的状态寄存器<code>STATUS REGISTER</code>置0，则其中的全局中断使能位也为0，禁用全局中断。</p><p>将<code>CP0</code>的<code>CONFIG</code>寄存器中值取出，将低三位置0又将第2位置1，则低三位K0区值为2，这时意为决定kseg0区不用高速缓存。</p><h1 id="实验难点"><a class="markdownIt-Anchor" href="#实验难点"></a> 实验难点</h1><h2 id="难点一-elf文件的解析"><a class="markdownIt-Anchor" href="#难点一-elf文件的解析"></a> 难点一 ELF文件的解析</h2><p><img src="/img/Lab01/lab1-elf.png" alt="image" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>   e_ident[EI_NIDENT];     <span class="hljs-comment">/* Magic number and other info */</span><br>    <span class="hljs-comment">// 存放魔数以及其他信息</span><br>    Elf32_Half      e_type;                 <span class="hljs-comment">/* Object file type */</span><br>    <span class="hljs-comment">// 文件类型 </span><br>    Elf32_Half      e_machine;              <span class="hljs-comment">/* Architecture */</span><br>    <span class="hljs-comment">// 机器架构</span><br>    Elf32_Word      e_version;              <span class="hljs-comment">/* Object file version */</span><br>    <span class="hljs-comment">// 文件版本</span><br>    Elf32_Addr      e_entry;                <span class="hljs-comment">/* Entry point virtual address */</span><br>    <span class="hljs-comment">// 入口点的虚拟地址</span><br>    Elf32_Off       e_phoff;                <span class="hljs-comment">/* Program header table file offset */</span><br>    <span class="hljs-comment">// 程序头表所在处与此文件头的偏移</span><br>    Elf32_Off       e_shoff;                <span class="hljs-comment">/* Section header table file offset */</span><br>    <span class="hljs-comment">// 节头表所在处与此文件头的偏移</span><br>    Elf32_Word      e_flags;                <span class="hljs-comment">/* Processor-specific flags */</span><br>    <span class="hljs-comment">// 针对处理器的标记</span><br>    Elf32_Half      e_ehsize;               <span class="hljs-comment">/* ELF header size in bytes */</span><br>    <span class="hljs-comment">// ELF文件头的大小（单位为字节）</span><br>    Elf32_Half      e_phentsize;            <span class="hljs-comment">/* Program header table entry size */</span><br>    <span class="hljs-comment">// 程序头表入口大小</span><br>    Elf32_Half      e_phnum;                <span class="hljs-comment">/* Program header table entry count */</span><br>    <span class="hljs-comment">// 程序头表入口数</span><br>    Elf32_Half      e_shentsize;            <span class="hljs-comment">/* Section header table entry size */</span><br>    <span class="hljs-comment">// 节头表入口大小</span><br>    Elf32_Half      e_shnum;                <span class="hljs-comment">/* Section header table entry count */</span><br>    <span class="hljs-comment">// 节头表入口数</span><br>    Elf32_Half      e_shstrndx;             <span class="hljs-comment">/* Section header string table index */</span><br>    <span class="hljs-comment">// 节头字符串编号</span><br>&#125; Elf32_Ehdr;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-comment">// section name</span><br>  Elf32_Word sh_name;<br>  <span class="hljs-comment">// section type</span><br>  Elf32_Word sh_type;<br>  <span class="hljs-comment">// section flags</span><br>  Elf32_Word sh_flags;<br>  <span class="hljs-comment">// section addr</span><br>  Elf32_Addr sh_addr;<br>  <span class="hljs-comment">// offset from elf head of this entry</span><br>  Elf32_Off sh_offset;<br>  <span class="hljs-comment">// byte size of this section</span><br>  Elf32_Word sh_size;<br>  <span class="hljs-comment">// link</span><br>  Elf32_Word sh_link;<br>  <span class="hljs-comment">// extra info</span><br>  Elf32_Word sh_info;<br>  <span class="hljs-comment">// alignment</span><br>  Elf32_Word sh_addralign;<br>  <span class="hljs-comment">// entry size</span><br>  Elf32_Word sh_entsize;<br> &#125;Elf32_Shdr;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-comment">// segment type</span><br>  Elf32_Word p_type;<br>  <span class="hljs-comment">// offset from elf file head of this entry</span><br>  Elf32_Off p_offset;<br>  <span class="hljs-comment">// virtual addr of this segment</span><br>  Elf32_Addr p_vaddr;<br>  <span class="hljs-comment">// physical addr, in linux, this value is meanless and has same value of p_vaddr</span><br>  Elf32_Addr p_paddr;<br>  <span class="hljs-comment">// file size of this segment</span><br>  Elf32_Word p_filesz;<br>  <span class="hljs-comment">// memory size of this segment</span><br>  Elf32_Word p_memsz;<br>  <span class="hljs-comment">// segment flag</span><br>  Elf32_Word p_flags;<br>  <span class="hljs-comment">// alignment</span><br>  Elf32_Word p_align;<br> &#125;Elf32_Phdr;<br><br></code></pre></td></tr></table></figure><p>这是<code>Lab1</code>的第一道难关，也是第一次上机的重要考点，在反复阅读代码以及ELF手册后，终于明白了ELF文件大概布局和格式。</p><h3 id="elf-header"><a class="markdownIt-Anchor" href="#elf-header"></a> ELF Header</h3><p>每个ELF文件有且仅有一个ELF Header，也就是上述定义为<code>Elf32_Ehdr</code>的结构体，在这里记录了整个ELF文件的重要信息，其中最值得关注的，例如：</p><ul><li><code>e_ident</code>：是ELF文件的标识符，一共16个字节的内容，其中前4字节又被称为魔数，用于标识这是一个ELF文件；第6个字节是数据编码格式，用于判断是小端存储还是大端存储。</li><li><code>e_entry</code>：程序入口的虚拟地址。</li><li><code>e_ehsize</code>：ELF文件头的大小。</li><li><code>e_phoff/e_shoff</code>：程序(节)头表的偏移地址，都是相对于ELF文件起始地址的偏移量</li><li><code>e_phentsize/e_shentsize</code>：程序(节)头表中每一表项的大小。</li><li><code>e_phnum/e_shnum</code>：程序(节)头表中表项的数量。</li></ul><p>了解后三个变量的定义后，就基本可以做出<code>exercise1.2</code>了。</p><h3 id="段与节"><a class="markdownIt-Anchor" href="#段与节"></a> 段与节</h3><p>这是ELF文件中间的部分，也是文件真正的内容所在。</p><p>ELF文件有三种格式：可重定位文件，共享目标文件和可执行文件。</p><p>当文件为可重定位文件时，我们将中间部分称为节，这时在文件末尾的节头表相对更重要，它记录了所有节的信息；</p><p>当文件为另外两种类型时，我们将中间部分称为段，这时在文件头部的程序头表更为重要，它记录了所有段的信息。</p><p>总而言之，节与段只是在不同文件中表现形式的区别，实际上是同一部分内容。一般来说，段的数量会少于节，因为一个段一般会包含多个节的内容。</p><h3 id="程序头表与节头表"><a class="markdownIt-Anchor" href="#程序头表与节头表"></a> 程序头表与节头表</h3><p>从ELF文件布局图中看，这两个表一个在文件开头，一个在文件结尾(实际布局可能有所差异)。</p><p>之前提到过ELF文件头对应于一个ELF文件，在文件中有且仅有一个。</p><p>但是对于<code>Elf32_Shdr, Elf32_Shdr</code>两个结构体，每一个结构体就是表中的一个表项，对应于实际ELF文件中的一个节或段，记录了对应节或段的重要信息，其数量往往对应于文件中节或段的数量。</p><p>访问这两个表就需要我们借助ELF文件头中的信息。</p><p>以<code>exercise1.2</code>中访问节头表为例，先用<code>e_shoff</code>加上文件的起始地址，访问节头表的基地址；然后以<code>e_shentsize</code>作偏移，依次访问每一个节头表项，而节头表项的数量从<code>e_shnum</code>即可得知。</p><h2 id="难点二-实战printf"><a class="markdownIt-Anchor" href="#难点二-实战printf"></a> 难点二 实战printf</h2><h3 id="处理长参数表"><a class="markdownIt-Anchor" href="#处理长参数表"></a> 处理长参数表</h3><p>这个其实并不难，按照指导书提供的参数表格式依次处理就好。</p><p>需要注意的是对于参数的初始化，如<code>width = prec = 0, padc = ' '</code>等。</p><h3 id="补充打印整数部分"><a class="markdownIt-Anchor" href="#补充打印整数部分"></a> 补充打印整数部分</h3><p>这部分也不难，相对其他部分，引入了<code>negFlag</code>这一变量，只需先对打印的参数进行判断，若为负数则将其变为正数并置<code>negFlag</code>为1。</p><h3 id="阅读代码并分析函数功能"><a class="markdownIt-Anchor" href="#阅读代码并分析函数功能"></a> 阅读代码并分析函数功能</h3><p>这一部分应该是完成<code>exercise1.5</code>的前置功课，这才是最难的部分，真正实操的部分反而简单。</p><p>一些宏函数和变量类型：</p><ul><li><code>va_list</code></li><li><code>va_start</code></li><li><code>va_arg</code></li><li><code>va_end</code></li></ul><p>以及三个<code>local help functions</code></p><ul><li><code>PrintNum</code></li><li><code>PrintChar</code></li><li><code>PrintString</code></li></ul><h1 id="实验心得与总结"><a class="markdownIt-Anchor" href="#实验心得与总结"></a> 实验心得与总结</h1><p>总的来说这一次实验总体难度水平中等偏难，相对于Lab0的入门实验，难度肯定是有了较大的提升。但是作为后续实验的基础来说，后续的实验只会更难。</p><p>在刚开始阅读指导书的时候，什么都不知道，一头雾水。能把每个分散的exercise做好，但是对整体的知识体系结构还是一无所知。</p><p>在完成printf实战之后再回头梳理整个脉络后，就会对Lab1的整体结构有个较为清楚的把握。</p><p>以总的<code>Makefile</code>为基础，可以将Lab1的几乎所有文件夹串联起来：</p><ul><li><p><code>boot</code>文件夹中的<code>start.S</code>主要与启动相关，负责初始化硬件，设置堆栈入口，以及跳转到<code>main</code>函数</p></li><li><p><code>drivers</code>文件夹主要与外部硬件设备相关，如实现输出字符的地址定义就在这里<code>console.c</code>文件中</p></li><li><p><code>include</code>文件夹主要包括了一些库函数，宏定义文件</p></li><li><p><code>lib</code>文件夹则是包含了实现<code>printf</code>的文件</p></li><li><p><code>tools</code>文件夹中是负责链接的文件，定义了内核入口地址</p></li><li><p><code>init</code>文件夹中则是初始化和<code>main</code>函数文件，在Lab1中体现不多，在Lab2则是重点</p></li><li><p><code>readelf</code>则是为了让我们手写函数去解析ELF文件</p></li><li><p><code>gxemul</code>中是仿真器的位置</p></li></ul><p>理解以后自然觉得不难，这样梳理以后就会对整体结构清晰很多。</p>]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab00</title>
    <link href="/2022/03/22/Lab00/"/>
    <url>/2022/03/22/Lab00/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h1><h2 id="thinking-01"><a class="markdownIt-Anchor" href="#thinking-01"></a> thinking 0.1</h2><h3 id="不同之处"><a class="markdownIt-Anchor" href="#不同之处"></a> 不同之处</h3><p>1.状态不同：第一次<code>add</code>之前，文件状态为<code>Untracked</code>，当<code>add</code>之后再次修改文件后，文件状态变为<code>Modified</code></p><p>2.操作不同：对于<code>Modified</code>状态下的文件，可以通过<code>git checkout -- &lt;file&gt;</code>将该文件变回修改前的状态</p><h3 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h3><p>对于已经<code>git add</code>的文件，文件已经进入暂存区，这时在工作区再次修改时，和<code>add</code>前的状态是不同的；且可以通过暂存区的文件对工作区进行恢复。</p><h2 id="thinking-02"><a class="markdownIt-Anchor" href="#thinking-02"></a> thinking 0.2</h2><p><code>add the file: git add; git commit</code></p><p><code>stage the file: git add</code></p><p><code>commit: git commit</code></p><h2 id="thinking-03"><a class="markdownIt-Anchor" href="#thinking-03"></a> thinking 0.3</h2><p><code>git checkout -- printf.c</code></p><p><code>git reset HEAD printf.c</code></p><p><code>git rm --cached Tucao.txt</code></p><h2 id="thinking-04"><a class="markdownIt-Anchor" href="#thinking-04"></a> thinking 0.4</h2><p>对于每一次<code>git commit</code>操作，文件都会在版本库中被记录下来。</p><p>通过<code>git reset --hard &lt;Hash-code&gt;</code>操作，可以回溯到任意一个曾经<code>commit</code>的版本。</p><h2 id="thinking-05"><a class="markdownIt-Anchor" href="#thinking-05"></a> thinking 0.5</h2><p>1.正确。</p><p>通过本地测试，在本地克隆远程仓库后，只会在本地检出<code>HEAD</code>指向的分支，一般为<code>main/master</code>分支。</p><p>2.正确。</p><p>这四条指令都是本地的状态和提交记录，与远程仓库无关。</p><p>3.错误。</p><p>克隆时所有分支都被克隆，但只有<code>HEAD</code>指向的分支被检出，需要在本地创建其他分支与远程仓库建立联系。</p><p>4.正确。</p><p>通过本地实验后发现是正确的。</p><h2 id="thinking-06"><a class="markdownIt-Anchor" href="#thinking-06"></a> thinking 0.6</h2><p><img src="/img/Lab00/Lab00-6.png" alt="image-20220315150110794" /></p><h2 id="thinking-07"><a class="markdownIt-Anchor" href="#thinking-07"></a> thinking 0.7</h2><h3 id="command"><a class="markdownIt-Anchor" href="#command"></a> command</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> Shell Start...&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo set a = 1&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> a=1 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo set b = 2&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> b=2 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo set c = a+b&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;c=$[$a+$b]&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo c = \$c&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save c to ./file1 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo $c&gt;file1&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save b to ./file2 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo $b&gt;file2&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save a to ./file3 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo $a&gt;file3&#x27;</span>&gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file1 file2 file3 to file4 &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;cat file1&gt;file4&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;cat file2&gt;&gt;file4&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;cat file3&gt;&gt;file4&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">echo</span> save file4 to ./result &gt;&gt; <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;cat file4&gt;&gt;result&#x27;</span> &gt;&gt; <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="result"><a class="markdownIt-Anchor" href="#result"></a> result</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">Shell Start...<br>set a = 1<br>set b = 2<br>set c = a+b<br>c = 3<br>save c to ./file1<br>save b to ./file2<br>save a to ./file3<br>save file1 file2 file3 to file4<br>save file4 to ./result<br>3<br>2<br>1<br></code></pre></td></tr></table></figure><p><code>echo echo Shell Start</code>与<code>echo 'echo Shell Start'</code>效果上没有区别；</p><p><code>echo echo \$c&gt;file1</code>后，‘file1’中内容为<code>echo $c</code>;</p><p><code>echo 'echo \$c&gt;file1'</code>后，标准输出为<code>echo \$c&gt;file1</code>。</p><h1 id="实验难点"><a class="markdownIt-Anchor" href="#实验难点"></a> 实验难点</h1><p><code>git</code>文件状态和恢复操作一图。</p><p><img src="/img/Lab00/Lab00-1.png" alt="" /></p><h1 id="总结感受"><a class="markdownIt-Anchor" href="#总结感受"></a> 总结感受</h1><p>在寒假预习了部分知识点的基础上，课下实验大约用4个小时左右的时间完成，总体来说Lab00课下实验难度不高。</p><p>Lab00主要在于对一些工具的了解和熟练掌握，在完成课下实验之后还需要不断学习巩固，为后面的学习做准备。</p><p>其中个人遇到的难点有：</p><p><code>git</code>操作较多，尤其是多种恢复操作，难以区分和记忆。</p><p><code>Linux</code>的<code>Shell</code>操作较多，熟练掌握需要一定的练习；<code>bash</code>批处理文件的编写也需要不断巩固，注意细节。</p>]]></content>
    
    
    <categories>
      
      <category>MOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
